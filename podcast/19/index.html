<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="76x76" href="../../assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="../../assets/favicon/site.webmanifest">
  <link rel="mask-icon" href="../../assets/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!-- other -->
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" data-ssr name="viewport">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Maven+Pro:wght@400;500;700&family=Playfair+Display:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/all.css" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/regular.css" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/brands.css" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/css/main.css">
  <link rel="alternate" type="application/rss+xml" href="https://feeds.buzzsprout.com/1817535.rss">
  <script src="../../assets/js/main.js" defer></script>
  <!-- from https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/62154131#62154131
        attempt to fix: https://github.com/haskellfoundation/haskellfoundation.github.io/issues/70
  -->
  <script>
    if (navigator && navigator.serviceWorker && navigator.serviceWorker.getRegistration) {
      navigator.serviceWorker.getRegistration('/').then(function(registration) {
        if (registration) {
          registration.update();
          registration.unregister();
        }
      });
    }
  </script>

  <!-- metadata -->
  <title>Marc Scholten</title>
  <meta property="og:title" content="Marc Scholten">
  
  <meta property="og:description" content="In this episode Marc Scholten is interviewed by Andres LÃ¶h and Joachim
Breitner. They talk about the Integrated Haskell Platform web framework
(IHP), implicit parameters and nix.
">
  

</head>

<body class="relative">

  <!-- This is the mobile fly-out menu - outside document flow. -->
  <div id="nav-backdrop" class="fixed z-10 inset-0 hidden"></div>

<div id="mobile-nav" class="fixed z-20 top-0 right-0 w-full sm:w-1/2 max-h-full overflow-auto hidden rounded-b shadow-lg bg-white px-4">

  <div class="pt-6 flex justify-between">

    <div>
      <img src="../../assets/images/logos/hf-logo-100-alpha.png" width="68" height="52" alt="Logo of the Haskell Foundation" />
      <div class="text-sm mt-2 text-gray-500">The Haskell Foundation</div>
    </div>

    <div class>
      <button id="mobile-nav-close" type="button" class="inline-flex items-center justify-center p-2 rounded text-purple-800 shadow-lg focus:outline-none">
        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

  </div>

  <div class="mt-6">
    <a href="../../" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Home</a>

    <div class="block py-3 border-t border-gray-320 text-lg font-medium text-gray-500">About</div>
    <a href="../../who-we-are" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Current Board</a>
    <a href="../../who-we-are/past-boards" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Past Boards</a>
    <a href="../../contact" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Contact</a>
    <a href="../../vision" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Vision</a>
    <a href="../../careers" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Careers</a>

    <a href="../../podcast" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Podcast</a>

    <a href="../../projects" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Projects</a>

    <a href="../../donations" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Sponsorship</a>

    <div class="block py-3 border-t border-gray-320 text-lg font-medium text-gray-500">Affiliates</div>
    <a href="../../affiliates" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Affiliates</a>
    <a href="../../affiliates/about" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">About Affiliating</a>

    <div class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium text-gray-500">News and Info</div>
    <a href="../../news" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">News</a>
    <a href="https://haskell-foundation.medium.com/" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Blog</a>
    <a href="../../news/press" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Press</a>
    <a href="../../resources" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Resources</a>
    <a href="../../faq" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">FAQ</a>

  </div>

</div>


  <!-- Document flow begins here -->
  <div class="min-h-screen flex flex-col">
    <div>
      <nav class="max-w-screen-xl mx-auto px-4 pt-6 sm:pt-12 sm:px-6 flex items-center justify-between justify-self-stretch">

  <div>
    <a href="../../">
      <img src="../../assets/images/logos/hf-logo-100-alpha.png" alt="The Haskell Foundation homepage" />
      <div class="text-sm mt-2 text-gray-500"></div>
    </a>
  </div>

  <nav class="hidden lg:block">
    <ul class="flex space-x-8 xl:space-x-12">


      <li class="relative">
        <a href="../../who-we-are" id="who-we-are-nav-item">About</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="who-we-are-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../who-we-are">
            Current Board
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../who-we-are/past-boards">
            Past Boards
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../contact">Contact</a>


          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../vision">Vision</a>
          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../careers">Careers</a>
        </div>

      </li>

      <li class="relative">
        <a href="../../podcast">Podcast</a>
      </li>

      <li class="relative">
        <a href="../../projects">Projects</a>

      </li>

      <li class="relative">
        <a href="../../donations">Sponsorship</a>

      </li>

      <li class="relative">
        <a href="../../affiliates" id="affiliates-nav-item">Affiliates</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="affiliates-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../affiliates">
            Affiliates
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../affiliates/about">
            About Affiliating
          </a>

        </div>

      </li>

      <li class="relative">
        <a href="../../news" id="news-nav-item">News and Info</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="news-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../news">
            News
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="https://haskell-foundation.medium.com/">
            Blog
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../news/press">
            Press
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../resources">Resources</a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../faq">FAQ</a>
        </div>

      </li>

    
      <li class="relative">
          <a class="dbox-donation-page-button" href="https://donorbox.org/donation-button-52?" style="background: rgb(94, 80, 134); color: rgb(255, 255, 255); text-decoration: none; font-family: Verdana, sans-serif; display: flex; gap: 8px; width: fit-content; font-size: 16px; border-radius: 5px; line-height: 24px; padding: 8px 24px;"><img src="https://donorbox.org/images/white_logo.svg">Donate</a>
      </li>
    </ul>
  </nav>

  <div class="absolute right-0 lg:hidden self-start">
    <button id="mobile-nav-open" type="button" class="mr-4 flex items-center justify-center p-2 rounded text-purple-800 shadow-lg focus:outline-none" aria-label="Main menu" aria-haspopup="true">
      <svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
      </svg>
    </button>
  </div>

</nav>

    </div>

    <div class="flex-grow">
      <div class="max-w-screen-xl mx-auto py-16 md:py-24">
  <div class="sm:px-6 lg:px-16">
  <div class="relative">
    <div class="absolute top-0 left-0 border-t border-l border-purple-50 h-10 md:h-20 w-10 md:w-20">
      <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-100 h-10 md:h-20 w-10 md:w-20">
        <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-200 h-10 md:h-20 w-10 md:w-20">
          <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-300 h-10 md:h-20 w-10 md:w-20">
            <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-400 h-10 md:h-20 w-10 md:w-20">
              <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-500 h-10 md:h-20 w-10 md:w-20"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="absolute top-0 right-0 border-t border-r border-purple-50 h-10 md:h-20 w-10 md:w-20">
      <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-100 h-10 md:h-20 w-10 md:w-20">
        <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-200 h-10 md:h-20 w-10 md:w-20">
          <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-300 h-10 md:h-20 w-10 md:w-20">
            <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-400 h-10 md:h-20 w-10 md:w-20">
              <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-500 h-10 md:h-20 w-10 md:w-20"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="text-center pt-12 md:pt-20 px-12 sm:px-16 md:px-24 lg:px-36 ">
    <h1 class="text-2xl-5xl"><b>19</b> â Marc Scholten</h1>
  </div>
</div>

<div class="max-w-screen-xl mx-auto">
  <div class="mx-auto prose md:prose-lg">
    <div class="space-y-8 max-w-2xl my-7 mx-auto">
      
      <p><em>Recorded 2022-11-11. Published 2022-12-07.</em></p>
      
      <p>In this episode Marc Scholten is interviewed by Andres LÃ¶h and Joachim Breitner. They talk about the Integrated Haskell Platform web framework (IHP), implicit parameters and nix.</p>
    </div>
  </div>

  <div class="mx-auto prose md:prose-lg my-6">
    <div id="buzzsprout-player-11829745"></div>
    <script src="https://www.buzzsprout.com/1817535/11829745.js?container_id=buzzsprout-player-11829745&player=small" type="text/javascript" charset="utf-8"></script>
  </div>

  
  <div class="mx-auto prose md:prose-lg my-6">
    <div class="flex items-center space-x-4">
      <!--
       TODO: Insert nice icon
       <div>
         <img class="h-10 md:h-16 lg:h-20" src="/assets/images/affiliated.svg" alt="">
       </div>
       -->
      <h2 class="text-2xl font-normal">Related links</h2>
    </div>
    <div class="border-l-3 border-gray-300 ml-5 md:ml-8 lg:ml-10 pl-4 md:pl-8 lg:pl-14 pr-4">
      <ul>
<li><a href="https://ihp.digitallyinduced.com/">Integrated Haskell Platform (IHP)</a></li>
<li><a href="https://www.digitallyinduced.com/">Digitally Induced</a></li>
<li><a href="https://ihp.digitallyinduced.com/Guide/hsx.html">HSX</a></li>
<li><a href="https://errors.haskell.org/">Haskell Error Index</a></li>
<li><a href="https://ghc-proposals.readthedocs.io/en/latest/proposals/0282-record-dot-syntax.html">Record Dot Syntax extension</a></li>
<li><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/implicit_parameters.html">Implicit parameters</a></li>
<li><a href="http://learnyouahaskell.com/">Learn You a Haskell (LYAH)</a></li>
<li><a href="http://www.aosabook.org/en/posa/warp.html">warp web server</a></li>
<li><a href="https://hackage.haskell.org/package/helium">Helium Compiler</a></li>
<li><a href="https://nixos.org/">Nix</a></li>
<li><a href="https://docs.shipnix.io/starters/ihp/">Shipnix</a></li>
</ul>
    </div>
  </div>
  

  
  <div class="mx-auto prose md:prose-lg my-6">
    <div class="flex items-center space-x-4">
      <!--
       TODO: Insert nice icon
       <div>
         <img class="h-10 md:h-16 lg:h-20" src="/assets/images/affiliated.svg" alt="">
       </div>
       -->
      <h2 class="text-2xl font-normal">Transcript</h2>
    </div>
    <div class="space-y-8 max-w-2xl my-7 mx-auto">
      <em>This transcript may contain mistakes. Did you find any?
      <a href="https://github.com/haskellfoundation/haskellfoundation.github.io/edit/hakyll/podcast/19/transcript.markdown">Feel free to fix them!</a></em>
    </div>
    <div class="border-l-3 border-gray-300 ml-5 md:ml-8 lg:ml-10 pl-4 md:pl-8 lg:pl-14 pr-4">
      <p><em>Andres LÃ¶h</em>: Welcome to the Haskell Interlude. I am Andres LÃ¶h and my host today is Joachim Breitner. Our guest for this episode is Marc Scholten, creator of the Integrated Haskell Platform web framework and founder of Digitally Induced. In this episode weâll learn why the IHP is the easiest way to get started with Haskell, why implicit parameters are massively underrated and why nix is the future is.</p>
<p><em>Joachim Breitner</em>: Marc, welcome.</p>
<p><em>Marc Scholten</em>: Hi, happy to be here.</p>
<p><em>AL</em>: Marc, why donât you tell us how you first came into the Haskell world?</p>
<p><em>MS</em>: I think itâs a good story. I started getting into Haskell in 2015, maybe. I first got introduced by a friend who told me âokay, this is a programming language, itâs very hard to learnâ. I found it as a cool and challenging kind of thing to look into. If itâs considered hard itâs a good probability to be something interestingâ¦</p>
<p><em>AL</em>: What kind of programming languages did you know at the time?</p>
<p><em>MS</em>: I was mostly working with PHP and other web stuff. NodeJS I think was just getting popular in 2015. Also, Ruby on Rails. So I basically started with PHP and the moved from there to Ruby on Rails and then NodeJS all the time. So I was already exposed to a lot of technologies. It was cool to see that there were still things that are considered hard that I donât know.</p>
<p><em>JB</em>: So these were all web technologies as far as I can tell. This is what you were doing at the time, web development? Or, what were you doing at that at that time?</p>
<p><em>MS</em>: I was working for a startup basically and I was doing web programming. So I basically started programming with web programming. I started with HTML and then kind of learned PHP to make it dynamic, in 2011 or something. So I always focused on web programming.</p>
<p><em>JB</em>: And how did you go about learning Haskell? I mean there are so many ways of doing that, and I guess you picked a successful one.</p>
<p><em>MS</em>: I pretty much learned programming by myself. I think a lot of people learn Haskell in university. But when I learned Haskell I was not in school. I was not at a university where people sometimes get to learn Haskell. I just Googled around and I found âLearn You A Haskellâ â thatâs why I still recommend it a lot. I learned by doing. I figured out it really changes the way you think about computer programs. At that point my thinking was very imperative, object oriented kind of thinking about how to design a program. And when youâre exposed to functional programming you kind of rewire your brain to think differently about problems. That made it actually very challenging at firs. Itâs easy to write your first couple of functions, like doing very simple expressions and stuff. But when actually try to compose programs out of these it gets very complicated because you donât know how to approach it. With imperative programming you know how to do it. But if you are in a functional project itâs hard to rethink that. That took me quite a while to get to know Haskell, understand how to build something in functional design and, basically, build small programs.</p>
<p><em>AL</em>: But I guess you must have liked it or otherwise you would not have stayed with this?</p>
<p><em>MS</em>: Yeah, I was actually exploring at the time some things related to F#. There was some website I saw that some examples of how you can use types to design your program and use that to drive everything. I found this really cool and thought this can be done with Haskell. So I found this kind of interesting. But I also quickly figured out that if you build a Haskell program, it actually mostly works when it compiles. I think this is a controversial thing to say on the podcast but, compared to NodeJS, itâs something like a fact that if you have a Haskell program and then it compiles it will most likely run successfully, even with no test, and in NodeJS.. good luck. It will mostly likely crash with some error message. I always complain about the Haskell error messages, but itâs also not that good in NodeJS.</p>
<p><em>JB</em>: No, I donât think itâs controversial to say that on a Haskell podcast. Itâs probably something that all of use have experienced while learning Haskell. Thatâs why we ended up staying involved. And thereâs certainly truth to that.</p>
<p><em>JB</em>: OK, so you got excited about Haskell as a thing to learn out of curiosity and, I guess, there was a challenge too. So, how did you go from there to starting a company around it?</p>
<p><em>MS</em>: I basically started Digitally Induced in 2006, right after finishing school. We basically started doing with startups, software systems for startups. It was just me at the time. I think our first projects were NodeJS and everything, because that was the job thing at the time. And that was kind of hard or painful to see how the quality was. You want to move fast and you want to do everything quickly and everything but then you have a lot of random errors. This is very painful to see when your system crashes in production. I was always thinking that Haskell can do this better and in reality we were using something like NodeJS and itâs always causing problems. Also, we were working with Ruby on Rails at the time and there I saw that you could work fast but you have to make a tradeoff with quality. With Haskell I could see that I can work fast and not have this tradeoff. So, as I was working with these technologies, I was side hacking with Haskell and playing around. I also wanted to do something with the web because thatâs my background. I started looking into how to use the Warp web server to get something done. I looked at the existing frameworks but I found them very complicated and did not use them very much. I was probably too inexperienced to work with them. So I just followed Stack Overflow and got Warp running. Then started building small things just playing with Warp and running from there. One thing I hated about Haskell was that Cabal was so slow. When you have PHP, or in Rails or NodeJS, you have very fast development cycles. In Haskell I didnât have that. So the first thing I did was for my Warp web server I just did a thing that just refreshes the thing in GHCi whenever something changes. I think in the first version we just told GHC to basically restart the program, which was still faster than Cabal. And this was the first thing that got turned into IHP, this reload cycle. At that time Iâm not sure if there was something like this in Haskell, but I was not looking for that. I was just thinking that I need something for faster development cycle so I have a similar experience like in other languages.</p>
<p><em>JB</em>: Did you say you were already using GHCi, the interpreter, to read out quickly, or were you just recompiling and restarting when you saved the file?</p>
<p><em>MS</em>: I think the first version was actually just recompiling but not with Cabal. So it was faster than Cabal, Cabal at that point was still very painful to use and I still remember at some point I actually got to a point where I had Cabal reinstall everything.</p>
<p><em>JB</em>: The Cabal hell.</p>
<p><em>MS</em>: Yes. I think it does not exist anymore. I think it has been fixed in the meantime, but in the past I had this multiple times. So I just tried to just have something that is fast, where I can make changes and see it on the web. I think I built from there, I just built whatever was missing to do what I wanted to do. This was quickly connecting to some database, the first version was just PostgreSQL. After a while I added the first code generator for database operations. In the past I was working with PHP ORM and in that ORM there was a lot of PHP code generation going on. So I basically just copied what I knew from there to Haskell, and that was part of what later became IHP.</p>
<p><em>AL</em>: OK, but if I understand you correctly the desire was to eventually get to use this on real web development projects for your clients at Digitally Induced. How soon did you achieve that goal? Was that easy once you had something up and running? Could you actually put it into production or was it a very long and difficult road?</p>
<p><em>MS</em>: At first it was actually not really the goal to have this. I was really just playing around with it, because I thought it was cool to play with the technology. After a while I wanted to use that because I saw the pain of using other technologies and thought this is so much better, why donât we use it instead? At that point we had the first couple of people working at the company and we had some smaller projects where we could use it, probably in 2017. There were smaller things where we could use it and we just tried it out because sometimes you have clients that donât really care about technologies because it doesnât matter that much. Itâs a small project and we could try it out, take a risk to see whether this works well and where it doesnât work. So we got the first project into production at that point, but there was still a very raw very, it was still a tiny wrapper around WAI, Warp and other Haskell libraries that were already there. So, step by step it kind of grew. We always added something when something was missing, or sometimes we just took the application code and extract to the framework step by step. I think also around the time we figured that this is something cool, seems like we have a pragmatic way to build Haskell stuff compared to what I consider complex web frameworks out there.</p>
<p><em>AL</em>: So, if we fast forward to today, how much of your company is now doing web applications for your clients? How much is developing IHP itself? Are you still doing projects in other languages or is it all Haskell now?</p>
<p><em>MS</em>: Basically IHP itself, the core, is open source. So we are not in the business of building IHP. We do a lot of projects with IHP at the moment. I think itâs half-half, we have still a lot of stuff from the past that is not with IHP, but we also have new projects that are using IHP. So, most of our work is focused on doing software with IHP and not really developing open source. Itâs also not good for the framework: the framework needs to be designed from the real world, not from thinking about the real world. Itâs better to build something specifically and then extract out the generic code, because then you know it actually covers the real world well, if you have done it in a couple of projects. These APIs are generally well designed. Some of the APIs in IHP are not designed that way and there are typically worse in quality and sometimes need to be rewritten a bit more. The stuff we extract from existing projects, these are things that really work.</p>
<p><em>JB</em>: Can you give us a concrete example of something where you design an API thinking it is good and then it turns out that just doesnât work in practice? A good anecdote you can tell us?</p>
<p><em>MS</em>: Oh, yeah. I think IHP serverside components are such a thing. Itâs like the IHP version of live view which projects such as Laravel have as well. We designed it because it was a cool experiment but itâs not been used in production by us in any project. For that it feels like it has certain limitations, and it would have been better if we would have used it directly in a project and then extract it out. Then it would not be missing critical stuff. With serverside components thereâs so much to do because itâs not designed. We just released it because it was a cool experiment and is still in that experimental phase. Itâs actually cool, I think some people donât know it exists, but I think itâs a cool way to work with IHP, though not that ready for production as other parts of IHP.</p>
<p><em>AL</em>: So perhaps we can talk a little bit more not from the historical perspective but from todayâs perspective. What IHP has to actually offer? I must admit from my own perspective mostly when I had something to do with web Iâve been working on the backend, my favorite framework is personally Servant. But why would I want to perhaps look at IHP? What are the cool extra things that I would be getting?</p>
<p><em>MS</em>: Generally, one of the IHP design values is that we want it to be very simple, in the sense that itâs easy to get started with it. Which makes IHP very friendly for everybody whoâs coming from other ecosystems, like Rails. For example, I think we have a lot of people coming from Rails, trying out IHP, because they like the kind of productiveness of Rails but want to have some more type safety. Or, we have people that work with Elm and think Haskell is very complicated compared to Elm and want to still build a backend for their web applications. One of the things we do really well in IHP is that we have this kind of thought out process from start to end on how the API is supposed to be used. So, if someone is just trying out Haskell, itâs probably the easiest way with IHP because we tell you all the steps and thereâs a lot of materials on when something goes wrong how you deal with that, and I think thatâs something which works really well. Taking that aside, we have a lot of good stuff, like HSX, which for someone that has been working with React is cool because itâs very similar and copies a lot of similar ideas to Haskell. We also have this integrated development tooling which saves a lot of time. Itâs really helpful because you can just quickly build something even without writing any code, which makes it a bit faster. Itâs a quick way to generate a lot of stuff and boilerplate. We have a lot of code generators and everything is kind of built in and you donât have to install like 10 packages to get started, this is one of the advantages. Compared to other frameworks, IHP is also full stack, so we are really designed for building applications where you build a backend and frontend in a single project. But in recent versions we also added APIs like IHP DataSync which allows to build React applications with DataSync. I think not enough people know about this, so itâs probably worth talking about it.</p>
<p><em>MS</em>: Weâve basically been looking at ways to work better with React. Because a lot of people use React with IHP, and even we do it in our projects. One thing thatâs always kind of painful when interfacing with React is you have to do the mapping of data structures from Haskell to your React application. And you always introduce some errors there and in the data mapping you always lose type safety and everything. Weâve been looking into ways to make this simple. We basically ported core IHP functions for the data layer, like <code>createRecord</code>, <code>updateRecord</code> and <code>deleteRecord</code> to JavaScript, so you could call these functions from the browser. So the syntax is very similar to the Haskell syntax and this allows you to build dynamic web components with an IHP system on the backend side. Direct interfacing works together which is really cool because you have the best of both words. You can do the hard stuff in the backend in Haskell and, when you have something very dynamic you can IHP DataSync to build a direct view and still access the same data without writing an API layer first. It works really great and makes everything real time. Weâve been just using this in a project to save so much time.</p>
<p><em>AL</em>: So I understand all of this. I found it interesting. Initially you said you want to make Haskell simpler, and I can understand from what you explain that basically the integrated aspect of IHP is a good vehicle to make it simple because it just answers a lot of questions for the programmer initially, like âhow do I do this?â, âhow do I do that?â. Thereâs a standard way to do things and thatâs documented and so on and so forth. But many people are perceiving the Haskell language itself to be complicated, right? Are you trying specifically in the Haskell code that you are generators to not use advanced features or all you embracing all that?</p>
<p><em>MS</em>: Thing is, Haskell language is probably simpler that many other languages, in the Core basically. If you look at the grammar of some popular languages, I think they are much more complicated. Haskell in that sense is much better designed. Itâs just that Haskell has too many options sometimes on how to approach things and that makes it complicated. Especially when you look at people who have been exposed to other programming languages and have this problem where you need to rewire the brain to understand it. When you then have so many options, I think thatâs where it feels complicated. But in IHP we try to not use what I would consider very complex features, just because of design trade-offs. So, if you saw âwe want to make IHP easy for people beginning Haskellâ we need to make sure that if you do basic operations in IHP that is not exposing you to stuff that is very fancy Haskell. Like if you need to write your own type instances for examples to get some basic operations and IHP running, I would consider this to be a problem because type families is problaby something you donât learn from the beginning when you are digging through how to write your first expressions and functions in Haskell.</p>
<p><em>JB</em>: I played around a little bit with IHP and I guess one example of where this design leads to is that most of the code is just plain IO monad and then you pass around environmental information using implicit parameters which I personally like in some context. But they are frowned upon by the majority of the community as far as I can tell. So would say that an experienced Haskell programmer in an independent approach surely shouldnât be using this pattern and should be using their favorite monad stack or <code>Free</code> monad or algebraic effects or whatever? But in the context of IHP you wanted to make it more approachable and therefore chose to use implicit parameters and a simple IO monad. Or are you saying this is actually a good pattern that people should be using more? Implicit parameters, just to pick an example, has a bad reputation for no good reason?</p>
<p><em>MS</em>: I would say itâs proven that this pattern actually work well. For me, I was actually not thinking about that because, for me, itâs just the way it is. But itâs actually a good point, most other people probably use monads more than us. We actually added a monad stack â we only have one â in the config side of IHP, this is now powered by a monad stack. I think this is a good point where the monad stack adds a lot of complexity because itâs like you need to understand how monads work and then you need to write a lot of boilerplate for connecting your stuff with the stack. The IO monad just works very well and implicit parameters are underrated in a sense, because they provide a similar thing as the Reader monad. But as the types are simpler you still have only plain functions. Because itâs passed implicitly, this is a good thing. Maybe I should start with why did we even add implicit parameters.</p>
<p><em>MS</em>: So, in the very first version of IHP I did not know about implicit parameters. We were just passing database connection to the functions that run a database query. But the problem is this adds a lot of noise to your program in the sense that in a web application you donât really care about the database connection. You really care about what is the functionâs query, so you want to have some focus on the data itself and not on the thing about querying the database. It doesnât matter that much how itâs queried, you just want to get the data out of it. If you always explicitly pass everything around it then everything is important, nothing is important. And you canât design your code in a way where you can focus on whatâs important and whatâs not important. For web applications certain things are what we consider important, and things that are not. Implicit parameters allow us to do exactly that. In a web application you always need to have certain things in the context, and this context contains the database connection, the logger, the base URL of your application and stuff like this that needs to be available. But you donât really want to explicitly pass this around to all functions because then all functions have like 10 arguments and it gets hard to read what matters. If you think about other web frameworks, like Rails â actually all other web frameworks in object oriented languages â they always do this. Implicit parameters is kind of what object oriented programmers do with this basically. We just copied this kind of thing and applied it to IHP with implicit parameters. Generally, it seems like thereâs no real downside of that. So weâve not seen a limitation and weâve probably written like tons of IHP applications from small to very large and itâs never been a limiting factor. Itâs advantage â there actually are advantages â is that the error messages are really good, compared to what you get if you a monad transformer stack, because there you have a myriad of instances, it gets very complicated quickly. With implicit parameters the error messages donât explode like in monad transformers.</p>
<p><em>AL</em>: Iâm trying to think back in time when I first encountered implicit parameters and I also have the feeling that Joachim has that somehow theyâve always had a little bit of a bad reputation. But Iâm actually wondering where this is coming from?</p>
<p><em>MS</em>: Thereâs one problem with implicit parameters, there are cases where you donât have the program behave as you think it should behave. But in IHP you donât manually deal with implicit parameters. Basically the framework passes the implicit parameters but you donât really manually handle them and that kind of avoids this problem. Otherwise you would probably run into edge cases but we kind of donât run into these edge cases.</p>
<p><em>AL</em>: Yes, but I can abuse many features, but it is a valid point that you have to have a little it of discipline and thatâs what IHP is doing. Itâs particularly well suited for this.</p>
<p><em>JB</em>: I think some of the criticism is about the way you provide them, which is something you wouldnât do in IHP framework as a user, where you have to let bind them and then itâs kind of implicit where it exits the scope. I think there are also examples where it appears to break referential transparency. You have an expression and you move it around and you donât know that the expression has an implicit parameter â this dependency is not made very explicit. And once you go to higher rank types and you put the implicit parameter in there, things become a bit more complicated. But these are things you wouldnât do as a user of IHP framework.</p>
<p><em>MS</em>: Yeah. This again, itâs like a tradeoff in the design space between wanting to make it simple to use but also keep like the great properties of Haskell. So, in practice, while it has these edge cases where it makes your program a bit more unstable or decreases quality, in our case it does not actually apply that much. So it is a tradeoff between making the programs simpler, easier to use and everything. And especially with dot notation, I think it provides an even more simpler approach. I hope this will get more popular outside of IHP in the future.</p>
<p><em>AL</em>: So one thing I was wondering was that on the one hand having everything integrated is really nice â certainly for people who want to start, and we can talk about perhaps a little bit more â, but itâs also making it sort of a harder sell for people who might want to switch, because it feels like you cannot try, for example, one particular component of IHP. At least at first it feels like itâs all of nothing. Is there a way to take it apart, even though perhaps thatâs not the intended way of using it? Is there a way of using some of the IHP functionality without doing everything?</p>
<p><em>MS</em>: At the moment not really. Itâs the full package deal at the moment. So, first step weâve done in this direction is weâve put HSX into its own package. So itâs its own package and can be used outside of IHP, basically. But in that case it made sense, because some people actually wanted to use it for other features. Some of the code is so intertwined to IHP and IHP way of thinking. IHP is not meant to be a library, itâs more like a real framework. There is this separation between a framework and a library where you can say you call the library but the framework calls you. So, IHP is more in the style where IHP provides a structure where you place the logic but IHP sees the whole control flow of the application.</p>
<p><em>AL</em>: Fair enough. So, if you now look at the users of IHP, would you think that they are, to a large extent, actually people who have not been using Haskell before or are you having many very experienced Haskell programmers among your users? Whatâs the kind of feedback youâre receiving?</p>
<p><em>MS</em>: I think we have a lot of people that are trying out Haskell. I think a lot of Haskell experts already have their framework of choice and donât want to switch. We have nearly 400 people on our Slack. So itâs already kind of a big community. We have a couple of thousand of users on the IHP mailing list. So itâs kind of its own subcommittee. A lot of people that are well known in the Haskell community sometimes are not that much into IHP because they have their own way of doing things already and maybe IHP is not a good fit for them. But we have a lot of people coming from Rails background, from Django background, etc. using IHP now. Another benefit we have in IHP now is that we have this great community that people having a problem about a specific IHP thing can just go on slack and ask a question and get an answer relatively quick because everyone is also working with the same IHP, same packages and everything. Because itâs always managed by Nix. Itâs always easy to get a problem solved because everybody is using everything pretty much the same way. This is also a certain advantage of the IHP community. But in general, I think a lot of people are just trying out Haskell and seeing IHP somewhere.</p>
<p><em>AL</em>: Thatâs great. Whatâs the outcome of this? Is it âIHP is great but I wish it didnât use Haskell underneathâ? Or âIHP is great because it gets me into Haskell and I want to do more Haskellâ? âI want to use this Haskell library that isnât in IHP, so please integrate it as well and make IHP even biggerâ? Whatâs the kind of pressures that you see on the wish list?</p>
<p><em>MS</em>: I think a lot of people are really loving IHP. A lot of people are really excited about IHP in general. If you actually go through IHP Slack thereâs lot of messages, for example just a random one, I think it was when we launched the 1.0: âLove what youâve done. Never used Haskell before. Will give it a goâ. This is kind of the idea we want to use IHP to give people a reason to use Haskell. Itâs like the entry drug to figuring out functional programming. I think a lot of people really get excited about this quickly. When they learn that they can have type safety and the productivity of something like Rails or Django, now they can learn more about Haskell because they get to write a bit more logic. First you just use a IHP schema designer to add your tables, you generate a couple of controllers. You modify a bit of HSX templates and everything works, now you already have an application running. Now you need to actually write your first logic and now you need to learn about Haskell. While itâs still probably a bit hard, you already have this feedback loop where you can see things on the screen and you can see output and see progress. So this makes it much better in general experience. I think a lot people then just go on with this journey and are very happy to use IHP and Haskell to build stuff. Weâve also seen people that think Haskell is their favorite kind of language but have not considered using it in their work projects. With IHP, sometimes, people have more confidence in using it for the work projects because it has a lot of the infrastructure that is needed for you to give confidence to it, basically. So people that want to use Haskell but cannot use it sometimes pick IHP because it provides a lot of things other framework maybe donât provide in the same sense.</p>
<p><em>AL</em>: Are there any things about Haskell or GHC or the tooling or the ecosystem that you think are painful to work with from your perspective, or that you think that IHP cannot easily fix and shield users from?</p>
<p><em>MS</em>: I think error messages are a core problem. The errors of GHC are sometimes too complicated are not really helpful. Itâs a big problem, because this is where people get stuck. Iâve seen this a couple of times where people that were live streaming IHP development â I followed that â and you someone gets stuck on an error message. You sit there and watch the stream and think âI know what the problem isâ, but the person streaming does not know and does not really understand. GHC sometimes tells you thereâs an error but maybe the error actually happens somewhere else or it just tells you the error in a very complicated language. Someone whoâs just trying it out the first time doesnât understand it. I think understanding GHC error messages is kind of a skill to learn and get used with with time. This makes it kind of a problem because people that have too much Haskell experience donât really fear this pain anymore. They just know when GHC says this you need to change this, itâs like pattern matching, youâve seen 10 times before and you know what you need to do. But if youâve seen this the first time, itâs complicated.</p>
<p><em>JB</em>: Maybe at this point we should advertise the project by the Haskell Foundation to create a Haskell Error Index, which is a website that will collect information for all the Haskell errors that Haskell produces. Then all the errors will get a number that you can Google for and youâll find a long explanation of things and that, hopefully, will help. Especially your audience here, so contributions are welcome. So, if anybody who listens here and wants to help with that, then Google for Haskell Error Index and start contributing and explain that.</p>
<p><em>MS</em>: Iâve been also talking with David from the Haskell Foundation, and before, Andrew, and told them that I hope we kind of help in that sense by complaining enough.</p>
<p><em>AL</em>: I think itâs pretty uncontroversial to say that GHCâs error messages could be better. I think most people would agree. Itâs just not always easy to figure out how, in some cases it might be not an easy problem to solve. But this error message index is certainly a step in the right direction. If you canât make them better or easier to understand on their own you can at least make it easier to find extra documentation about them. Also, one aspect is just that often they tend to be very verbose, they have lots of information in them but in practice you only need a very small part and itâs very difficult at the moment to remove the extra information. But if the information is in a separate index for documentation, then perhaps this can actually be fixed. But I think (getting) good error message is a difficult problem. In the past, at Utrecht University where the Helium compiler was designed for a while â this was a Haskell compiler that was specifically designed to have good error messages for beginners. There was a lot of effort being put into giving meaningful type error messages, but it only ever supported Haskell98, or a very small part compared to what people today consider to be proper Haskell. Even type classes were difficult to add. If you see all the extra features that GHC has over standard Haskell, there are quite a few error situations where itâs basically an unsolved problem. Unfortunately, I think in the research world, itâs not rewarded to work on good error messages, or not sufficiently rewarded. So researchers get their research credits for adding new features to languages or proposing new features. But saying âI can produce a better error message for this well-known issueâ is unlikely to make academics really excited and thatâs perhaps a bit sad.</p>
<p><em>MS</em>: One example I can think of is the new (record) dot notation, which is actually one of the most underrated features in Haskell â it took a while to get finally merged. I was following that RFC for a while. I think itâs a great feature, but the problem is that now if you mistype a field, for example, it does not say that this data structure does not have the field, it gives you a missing instance error. Basically, it makes sense because itâs just a wrap around the <code>HasField</code> class, right? In this case, itâs technically correct. But as a user if you just learn Haskell you think âcool, this dot notation I know from JavaScript or some other programming language and Iâll use itâ. You would expect to just tell you âokay, this field does not existâ but basically it gives you typeclass errors which is not helpful.</p>
<p><em>AL</em>: Basically itâs an implementation detail leaking, right? You have a very general mechanism â which is justified, I guess â but then most people think about this dot operator just as field projection and it would be nice for the common case to get sort of an error message in those terms, without exposing all the underlying generality. I think thatâs a very common problem for Haskell where we build our own EDSLs and layers upon layers of abstraction and this encourages people to just learn the DSL â âhow can I use this little sublanguage within Haskell?â. But the moment you get an error youâre back to square one, because the error message is exposing all the nitty-gritty underlying details of the implementation. And then you have to understand how it is implemented. I donât want to talk too much about Helium, but thereâs another nice feature that it had back then that, for DSLs, you could get DSL specific messages. For example for parser combinators if you would a type error with parser combinators you would get an error message that is specific to the user of parser combinators. Perhaps, it would be a good idea to try to add something like this to GHC as well. Sometimes we can just hide some of the underlying complexity for those cases where youâre actually thinking on a different level about your program.</p>
<p><em>JB</em>: So youâre not only using Haskell as some kind of cool project that you want to expose people to, but the whole thing actually uses Nix to get IHP on the user machines. I guess this is another of those obviously correct but still bold technology choices, from my point of view. In this case itâs a bit strange because youâre building a framework where you control everything, so it wouldnât be too hard to just bundle it up in all bundle with a few static binaries in there you place on your path and youâre done. So Iâm wondering how did that go for you? Is it causing trouble? Are people happy about it? Is it something that your beginning users, or entry level users donât even notice that thereâs something interesting underneath?</p>
<p><em>MS</em>: I think Nix is also underrated. Itâs probably even more underrated than Haskell. Itâs now getting to the point where itâs really good and brings more advantages than painful experiences. I think in the first release of IHP in 2020, we had a lot of people â there was even a GitHub issue â that asked us to remove Nix and just offer something else because some people got burned by this and then they donât want to touch it again. It was more painful in the past. Installing Nix on MacOS was really broken and then there was also a problem on M1 Macs for a while. So it has caused some problems but I think there are actually some advantages â and we see this in practice: we have projects from 2017-2018 here, these very old projects, where we had the first version of IHP, and we still can run them. We just go to the project and we run it â except under M1 Mac, thereâs a problem, we need to update to later packages. But on a normal Mac you just can still run it. Try that with npm projects. We have npm projects where after half a year we are not sure if we can get back to the project without spending a lot of time to get it working again, because it moves so fast. With Nix you just know it will work again. So this also simplifies a lot of the deployment. Like building a docker image is super simple. At Digitally Induced we just do a lot of different projects and when you switch between these projects itâs a bit of pain to get the dependencies and everything running as it was in the past. There was Vagrant that was very popular in 2005, before Docker became popular. It worked really well and provided a really great experience where you could just type <code>vagrant up</code> and you were in the project and everything was working. I think <code>docker compose</code> now has a similar experience, but itâs not really there with Docker. We really wanted to have the same experience but with Nix instead. I donât think itâs such a big problem in practice anymore. I think Nix is really where the future is going to be, so IHP is really positioned for that. Other people on HackerNews commented that combining Haskell with Nix is like a competition of the worst ideas. But I think theyâre a great fit. Hopefully more people when they use IHP will then figure out that Nix is actually a really cool technology and continue to use it. It happened that a lot of people have kind of been exposed to Nix and figured out a bit more of everything. For example, one of the people in the IHP community is building this Shipnix service, if someone want to try it out. He got into Nix just by being exposed to IHP and now heâs building kind of a service where you can even deploy stuff with Nix. I think this is really cool. Nix, generally, in 10 years will probably be very very popular. It took a couple of years to get Nix to a point where itâs productive to use. Itâs an exciting technology in general.</p>
<p><em>AL</em>: I certainly can share some of your experiences. Iâm using Nix for a long time as well and as a Haskell consultant, we also work with clients having various different configurations â thatâs just one aspect thatâs always been very pleasant. I mean obviously you build completely different environments and docker images and so forth, but just setting up various different toolchains and dependencies and environments using Nix is very quick. I guess the question in the context of IHP is: youâre integrating already quite a few design choices and then youâre integrating yet another rather substantial design choice as to what kind of OS tooling youâre using. If the goal is to have something integrated with everything then perhaps thatâs not a big blocker in any way?</p>
<p><em>MS</em>: Nix also allows us to bundle the PostgreSQL server. Folks have a good simple case, where in dev mode they use sqlite and this is not great because in sqlite you donât many of the features that make PostgreSQL great - like constraints I think are not available in sqlite. So you can easily do something that works in dev mode but then doesnât work in production, because your build mode is different. Iâve seen this a lot of times. The problem is when you set up PostgreSQL and you have a lot of projects â which we have as a company â you sometimes have different PostgreSQL versions and everything. And then itâs a pain to work with a project. The experience with sqlite in general is great, everything is bundled in the project. But you donât have to do the manual setup of PostgreSQL to get the technical advantage of PostgreSQL, you donât want to have the setup cost associated with that. With Nix, you can basically get both. We can have bundled PostgreSQL, without any manual setup. Itâs all done by the integrated server of IHP, it just calls PostgreSQL and starts the server locally.</p>
<p><em>AL</em>: As weâre close to the end, we should look a little bit to the future. Youâve recently released IHP 1.0. So what are your plans? Continue evolving it, making it even more successful than it already is? Or are there big new things on the horizon or also big developments in the Haskell community youâre looking forward to?</p>
<p><em>MS</em>: I think in general the core thing is not making it much more popular. I think itâs already very popular in terms of number of projects. I think from a technical side there are still a lot of things we want to actually ship which we sadly didnât get in version 1. One of this is internationalization. We had some projects where we have implemented internationalization already, just not fully extracted into IHP. So some parts are work for internationalization. For example the URL generation and routing system actually can do internationalization now but itâs not documented and a lot of other parts are not extracted to IHP yet. So this is something that we will add on the future. Nix flakes I think will be very cool. I think this will help us make the current setup a bit more streamlined. Nix flakes is still experimental feature and should not yet be used without a flag. I think these are some of the features weâd like from a technical side. Outside that, we really just want to grow the ecosystem. I think thereâs a lot of companies that could get a lot of value by using IHP. And we see even more companies adopting that. We have a lot of interesting companies that you would not think they use Haskell. A lot of these companies evaluate what are the framework like, the most active working framework and stuff and then some of these pick up IHP and we get to work with them and do interesting stuff. I think this can grow more if we grow the IHP ecosystem. The overall mission of IHP is really to make Haskell more popular, in the sense of how Ruby was made more popular from Rails. We basically want to do the same thing for Haskell. Then you have a killer application in the Haskell ecosystem for people to start using Haskell and experience the great technology that is available within the Haskell ecosystem. IHP really wants to be that.</p>
<p><em>JB</em>: So thatâs the future of IHP and what good it would do for Haskell. What do you expect from Haskell to become or to do in the future to benefit IHP? What is your wish list?</p>
<p><em>MS</em>: First, donât remove implicit parameters. This would be bad. I think in general error messages. Dot notation was my favorite feature that has been added in a long time. Itâs now been added so thatâs good. I think also making compile times faster could be a thing. Generally anything that makes the experience better. I donât think, for example, thereâs a lot of development into making Haskell even more type safe, but I donât think this is valuable because you get most of the value just by switching from something else to Haskell. By making Haskell more type safe you might catch a couple more errors but itâs diminishing returns and itâs probably better to spend resources to focus on general experience, like making everything faster and better error messages.</p>
<p><em>AL</em>: I think thatâs a nice message to conclude on. Thank you so much Marc for taking the time to talk to us. And good luck with making Haskell and the IHP yet more popular.</p>
<p><em>MS</em>: Thanks for having me and for everybody listening who has not yet tried out IHP, maybe just try it out and if you have any feedback feel free to share in the IHP community. Iâm happy to hear what everybody from the community is thinking about IHP. Feel free to join the IHP community if youâre interested to see whatâs going on there.</p>
<p><em>JB</em>: Thank you.</p>
<p><em>AL</em>: Thanks.</p>
<p><em>Sponsors</em>: The Haskell Interlude Podcast is a project of the Haskell Foundation, and it is made possible by the support of our sponsors, especially the Monad-level sponsors: Digital Asset, GitHub, Input Output, Juspay, and Meta.</p>
    </div>
  </div>
  
</div>

    </div>

    <div class="max-w-screen-xl mx-auto text-center sm:px-12 md:px-12 lg:px-16 mt-32">
  <div class="font-bold">SPONSORS</div>

  <div class="mt-16">
    <div class="font-bold">Monads</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://iohk.io/" target="_blank" class="block w-48 m-4"><img alt="IOHK" src="../../assets/images/sponsors/iohk/iohk-683.png" srcset="../../assets/images/sponsors/iohk/iohk-200.png 200w, /assets/images/sponsors/iohk/iohk-400.png 400w, /assets/images/sponsors/iohk/iohk-683.png 683w"></a>
    
    <a href="https://juspay.in" target="_blank" class="block w-48 m-4"><img alt="Juspay" src="../../assets/images/sponsors/juspay/juspay_logo.png"></a>
    
    <a href="https://mercury.com/" target="_blank" class="block w-48 m-4"><img alt="Mercury" src="../../assets/images/sponsors/mercury/mercury.png"></a>
    
  </div>

  <div class="mt-16">
    <div class="font-bold">Applicatives</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://www.sc.com/en/" target="_blank" class="block w-36 m-4"><img alt="Standard Chartered" src="../../assets/images/sponsors/standard-chartered/scb-logo.png"></a>
    
    <a href="https://tweag.io/" target="_blank" class="block w-36 m-4"><img alt="Tweag" src="../../assets/images/sponsors/tweag/tweag-683.png" srcset="../../assets/images/sponsors/tweag/tweag-200.png 200w, /assets/images/sponsors/tweag/tweag-400.png 400w, /assets/images/sponsors/tweag/tweag-683.png 683w"></a>
    
    <a href="https://well-typed.com/" target="_blank" class="block w-36 m-4"><img alt="Well-Typed" src="../../assets/images/sponsors/well-typed/well-typed-683.png" srcset="../../assets/images/sponsors/well-typed/well-typed-200.png 200w, /assets/images/sponsors/well-typed/well-typed-400.png 400w, /assets/images/sponsors/well-typed/well-typed-683.png 683w"></a>
    
  </div>

  <div class="mt-16">
    <div class="font-bold">Functors</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://www.channable.com/" target="_blank" class="block w-24 m-4"><img alt="Channable" src="../../assets/images/sponsors/channable/channable-683.png" srcset="../../assets/images/sponsors/channable/channable-200.png 200w, /assets/images/sponsors/channable/channable-400.png 400w, /assets/images/sponsors/channable/channable-683.png 683w"></a>
    
    <a href="https://www.digitalocean.com" target="_blank" class="block w-24 m-4"><img alt="DigitalOcean" src="../../assets/images/sponsors/digital-ocean/DO-logo-683.png" srcset="../../assets/images/sponsors/digital-ocean/DO-200.png 200w, /assets/images/sponsors/digital-ocean/DO-400.png 400w, /assets/images/sponsors/digital-ocean/DO-logo-683.png 683w"></a>
    
    <a href="https://opensource.google/" target="_blank" class="block w-24 m-4"><img alt="Google" src="../../assets/images/sponsors/google/google-683.png" srcset="../../assets/images/sponsors/google/google-200.png 200w, /assets/images/sponsors/google/google-400.png 400w, /assets/images/sponsors/google/google-683.png 683w"></a>
    
    <a href="https://www.digitalocean.com" target="_blank" class="block w-24 m-4"><img alt="QBayLogic" src="../../assets/images/sponsors/qbaylogic/qbaylogic-logo-683.png" srcset="../../assets/images/sponsors/qbaylogic/qbaylogic-200.png 200w, /assets/images/sponsors/qbaylogic/qbaylogic-400.png 400w, /assets/images/sponsors/qbaylogic/qbaylogic-logo-683.png 683w"></a>
    
    <a href="https://tripshot.com/" target="_blank" class="block w-24 m-4"><img alt="TripShot" src="../../assets/images/sponsors/tripshot/Tripshot_Logo_RGB.png"></a>
    
  </div>
</div>

<div class="mt-20 bg-gray-800 w-full py-20">
  <div class="max-w-screen-xl mx-auto text-gray-300 text-lg px-6 lg:px-16">

    <div class="flex flex-col space-y-8 text-center lg:flex-row lg:space-y-0">
      <div class="lg:flex space-y-4 lg:gap-2 lg:flex-grow lg:space-y-0">
        <div class="font-medium mt-1">To learn more about the Haskell Foundation </div>
        <div class="ml-2">
          <a href="../../contact" class="arrow-link light">>> contact us</a>
        </div>
      </div>

      <div class="flex space-x-4 w-44">
        <a href="https://twitter.com/haskellfound" target="_blank" class="text-4xl block"><span class="fab fa-twitter"></span></a>
        <a href="https://www.linkedin.com/company/haskell-foundation-inc" target="_blank" class="text-4xl block"><span class="fab fa-linkedin-in"></span></a>
        <a href="https://discourse.haskell.org/c/haskell-foundation/11" target="_blank" class="text-4xl block"><span class="fab fa-discourse"></span></a>
        <a rel="me" href="https://mastodon.social/@haskell_foundation" target="_blank" class="text-4xl block"><span class="fab fa-mastodon"></span></a>
        <a href="https://www.youtube.com/@HaskellFoundation" target="_blank" class="text-4xl block"><span class="fab fa-youtube"></span></a>
        <a href="https://github.com/haskellfoundation" target="_blank" class="text-4xl block"><span class="fab fa-github"></span></a>
      </div>
    </div>

    <div class="flex flex-row">
      <div class="mt-16 flex flex-col text-center flex-grow lg:flex-row lg:space-x-8 lg:space-y-0">
        <img src="../../assets/images/logos/hf-logo-100-alpha.png" class="h-8" alt="Logo of the Haskell Foundation" />
        <div class="font-medium">2024 Â© Haskell Foundation, <a href="https://github.com/haskellfoundation/haskellfoundation.github.io">submit website bug reports and fixes on GitHub</a></div>
      </div>

      <div class="text-sm mt-6 flex ml-8 flex-col justify-items-start text-left">
        <div>Haskell Foundation, Inc.</div>
        <div>2093 Philadelphia Pike #8119</div>
        <div>Claymont, DE 19703</div>
        <div>USA</div>
      </div>
    </div>

  </div>
</div>

  </div>

</body>

</html>
