<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="76x76" href="../../assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="../../assets/favicon/site.webmanifest">
  <link rel="mask-icon" href="../../assets/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!-- other -->
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" data-ssr name="viewport">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Maven+Pro:wght@400;500;700&family=Playfair+Display:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/all.css" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/regular.css" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/brands.css" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/css/main.css">
  <link rel="alternate" type="application/rss+xml" href="https://feeds.buzzsprout.com/1817535.rss">
  <script src="../../assets/js/main.js" defer></script>
  <!-- from https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/62154131#62154131
        attempt to fix: https://github.com/haskellfoundation/haskellfoundation.github.io/issues/70
  -->
  <script>
    if (navigator && navigator.serviceWorker && navigator.serviceWorker.getRegistration) {
      navigator.serviceWorker.getRegistration('/').then(function(registration) {
        if (registration) {
          registration.update();
          registration.unregister();
        }
      });
    }
  </script>

  <!-- metadata -->
  <title>Simon Peyton Jones</title>
  <meta property="og:title" content="Simon Peyton Jones">
  
  <meta property="og:description" content="Simon Peyton Jones is interviewed by Andres LÃ¶h and Joachim Breitner.
Simon is the creator of Haskell and in this episode he talks about his
new position at Epic, the origins of Haskell and why &quot;it feels right&quot;,
and the (extra)ordinary Haskell programmers.
">
  

</head>

<body class="relative">

  <!-- This is the mobile fly-out menu - outside document flow. -->
  <div id="nav-backdrop" class="fixed z-10 inset-0 hidden"></div>

<div id="mobile-nav" class="fixed z-20 top-0 right-0 w-full sm:w-1/2 max-h-full overflow-auto hidden rounded-b shadow-lg bg-white px-4">

  <div class="pt-6 flex justify-between">

    <div>
      <img src="../../assets/images/logos/hf-logo-100-alpha.png" width="68" height="52" alt="Logo of the Haskell Foundation" />
      <div class="text-sm mt-2 text-gray-500">The Haskell Foundation</div>
    </div>

    <div class>
      <button id="mobile-nav-close" type="button" class="inline-flex items-center justify-center p-2 rounded text-purple-800 shadow-lg focus:outline-none">
        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

  </div>

  <div class="mt-6">
    <a href="../../" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Home</a>

    <div class="block py-3 border-t border-gray-320 text-lg font-medium text-gray-500">About</div>
    <a href="../../who-we-are" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Current Board</a>
    <a href="../../who-we-are/past-boards" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Past Boards</a>
    <a href="../../contact" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Contact</a>
    <a href="../../vision" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Vision</a>
    <a href="../../careers" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Careers</a>

    <a href="../../podcast" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Podcast</a>

    <a href="../../projects" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Projects</a>

    <a href="../../donations" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Sponsorship</a>

    <div class="block py-3 border-t border-gray-320 text-lg font-medium text-gray-500">Affiliates</div>
    <a href="../../affiliates" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Affiliates</a>
    <a href="../../affiliates/about" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">About Affiliating</a>

    <div class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium text-gray-500">News and Info</div>
    <a href="../../news" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">News</a>
    <a href="../../news/press" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Press</a>
    <a href="../../resources" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Resources</a>
    <a href="../../faq" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">FAQ</a>

  </div>

</div>


  <!-- Document flow begins here -->
  <div class="min-h-screen flex flex-col">
    <div>
      <nav class="max-w-screen-xl mx-auto px-4 pt-6 sm:pt-12 sm:px-6 flex items-center justify-between justify-self-stretch">

  <div>
    <a href="../../">
      <img src="../../assets/images/logos/hf-logo-100-alpha.png" alt="The Haskell Foundation homepage" />
      <div class="text-sm mt-2 text-gray-500"></div>
    </a>
  </div>

  <nav class="hidden lg:block">
    <ul class="flex space-x-8 xl:space-x-12">


      <li class="relative">
        <a href="../../who-we-are" id="who-we-are-nav-item">About</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="who-we-are-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../who-we-are">
            Current Board
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../who-we-are/past-boards">
            Past Boards
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../contact">Contact</a>


          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../vision">Vision</a>
          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../careers">Careers</a>
        </div>

      </li>

      <li class="relative">
        <a href="../../podcast">Podcast</a>
      </li>

      <li class="relative">
        <a href="../../projects">Projects</a>

      </li>

      <li class="relative">
        <a href="../../partnerships">Partnerships</a>
      </li>

      <li class="relative">
        <a href="../../donations">Sponsorship</a>

      </li>

      <li class="relative">
        <a href="../../affiliates" id="affiliates-nav-item">Affiliates</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="affiliates-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../affiliates">
            Affiliates
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../affiliates/about">
            About Affiliating
          </a>

        </div>

      </li>

      <li class="relative">
        <a href="../../news" id="news-nav-item">News and Info</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="news-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../news">
            News
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../news/press">
            Press
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../resources">Resources</a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../faq">FAQ</a>
        </div>

      </li>


      <li class="relative">
          <a class="dbox-donation-page-button" href="https://donorbox.org/donation-button-52?" style="background: rgb(94, 80, 134); color: rgb(255, 255, 255); text-decoration: none; font-family: Verdana, sans-serif; display: flex; gap: 8px; width: fit-content; font-size: 16px; border-radius: 5px; line-height: 24px; padding: 8px 24px;"><img src="https://donorbox.org/images/white_logo.svg">Donate</a>
      </li>
    </ul>
  </nav>

  <div class="absolute right-0 lg:hidden self-start">
    <button id="mobile-nav-open" type="button" class="mr-4 flex items-center justify-center p-2 rounded text-purple-800 shadow-lg focus:outline-none" aria-label="Main menu" aria-haspopup="true">
      <svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
      </svg>
    </button>
  </div>

</nav>

    </div>

    <div class="flex-grow">
      <div class="max-w-screen-xl mx-auto py-16 md:py-24">
  <div class="sm:px-6 lg:px-16">
  <div class="relative">
    <div class="absolute top-0 left-0 border-t border-l border-purple-50 h-10 md:h-20 w-10 md:w-20">
      <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-100 h-10 md:h-20 w-10 md:w-20">
        <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-200 h-10 md:h-20 w-10 md:w-20">
          <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-300 h-10 md:h-20 w-10 md:w-20">
            <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-400 h-10 md:h-20 w-10 md:w-20">
              <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-500 h-10 md:h-20 w-10 md:w-20"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="absolute top-0 right-0 border-t border-r border-purple-50 h-10 md:h-20 w-10 md:w-20">
      <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-100 h-10 md:h-20 w-10 md:w-20">
        <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-200 h-10 md:h-20 w-10 md:w-20">
          <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-300 h-10 md:h-20 w-10 md:w-20">
            <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-400 h-10 md:h-20 w-10 md:w-20">
              <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-500 h-10 md:h-20 w-10 md:w-20"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="text-center pt-12 md:pt-20 px-12 sm:px-16 md:px-24 lg:px-36 ">
    <h1 class="text-2xl-5xl"><b>11</b> â Simon Peyton Jones</h1>
  </div>
</div>

<div class="max-w-screen-xl mx-auto">
  <div class="mx-auto prose md:prose-lg">
    <div class="space-y-8 max-w-2xl my-7 mx-auto">
      
      <p><em>Recorded 2022-02-01. Published 2022-03-25.</em></p>
      
      <p>Simon Peyton Jones is interviewed by Andres LÃ¶h and Joachim Breitner. Simon is the creator of Haskell and in this episode he talks about his new position at Epic, the origins of Haskell and why âit feels rightâ, and the (extra)ordinary Haskell programmers.</p>
    </div>
  </div>

  <div class="mx-auto prose md:prose-lg my-6">
    <div id="buzzsprout-player-10316819"></div>
    <script src="https://www.buzzsprout.com/1817535/10316819.js?container_id=buzzsprout-player-10316819&player=small" type="text/javascript" charset="utf-8"></script>
  </div>

  
  <div class="mx-auto prose md:prose-lg my-6">
    <div class="flex items-center space-x-4">
      <!--
       TODO: Insert nice icon
       <div>
         <img class="h-10 md:h-16 lg:h-20" src="/assets/images/affiliated.svg" alt="">
       </div>
       -->
      <h2 class="text-2xl font-normal">Related links</h2>
    </div>
    <div class="border-l-3 border-gray-300 ml-5 md:ml-8 lg:ml-10 pl-4 md:pl-8 lg:pl-14 pr-4">
      <ul>
<li><a href="https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/">A History of Haskell: being lazy with class</a></li>
<li><a href="https://crypto.stanford.edu/~blynn/compiler/miranda.html">Miranda language</a></li>
<li><a href="https://www.haskell.org/definition/haskell-report-1.0.ps.gz">Haskell 1.0 Report (postscript)</a></li>
<li><a href="https://www.haskell.org/onlinereport/">Haskell 98 Report</a></li>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/">Haskell 2010 Report</a></li>
<li><a href="https://crypto.stanford.edu/~blynn/compiler/golf.html">Combinator Golf</a></li>
<li><a href="https://doisinkidney.com/posts/2020-10-17-ski.html">Fun with Combinators</a></li>
<li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Liquid Haskell</a></li>
<li><a href="https://www.microsoft.com/en-us/research/">Microsoft Research</a></li>
<li><a href="https://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf">Notions of computation and monads (PDF)</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/tackling-awkward-squad-monadic-inputoutput-concurrency-exceptions-foreign-language-calls-haskell/">Tackling the awkard squad</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/trees-that-grow/">Trees that grow</a></li>
</ul>
    </div>
  </div>
  

  
  <div class="mx-auto prose md:prose-lg my-6">
    <div class="flex items-center space-x-4">
      <!--
       TODO: Insert nice icon
       <div>
         <img class="h-10 md:h-16 lg:h-20" src="/assets/images/affiliated.svg" alt="">
       </div>
       -->
      <h2 class="text-2xl font-normal">Transcript</h2>
    </div>
    <div class="space-y-8 max-w-2xl my-7 mx-auto">
      <em>This transcript may contain mistakes. Did you find any?
      <a href="https://github.com/haskellfoundation/haskellfoundation.github.io/edit/hakyll/podcast/11/transcript.markdown">Feel free to fix them!</a></em>
    </div>
    <div class="border-l-3 border-gray-300 ml-5 md:ml-8 lg:ml-10 pl-4 md:pl-8 lg:pl-14 pr-4">
      <p><em>Andres LÃ¶h</em>: Hello Simon. Thank you so much for joining us today.</p>
<p><em>Simon Peyton Jones</em>: Hi Andres, hi Joachim.</p>
<p><em>Joachim Breitner</em>: Hello.</p>
<p><em>AL</em>: I heard that you have recently started a new job at Epic Games. Is there anything you can tell us about that?</p>
<p><em>SPJ</em>: Yes I have. Itâs very exciting. So Iâve left Microsoft Research at the end of November after 21 years. Working for Microsoft Research has been a huge part of my life and itâs been a great privilege to work there actually because it allowed me to do more or less whatever I liked, which is pretty amazing as a job description. So I spent some time working on education, about around 1 day / week all told, and then the rest of my time on functional programming research and on projects related to Microsoft. My new job with Epic actually is with a fairly similar prospectus. Epic are very generously allowing me to continue to spend time on functional programming research and on education. But the balance of my time now will be spent on working with Lennart Augustsson and the Verse team on this programming language, Verse which is going to be a sort of extension language for the metaverse that Epic will sort of build out starting from the base that they have with the Unreal Engine and their sort of games, Fortnite in particular.</p>
<p><em>AL</em>: Is there any particular connection between Verse and Haskell that makes Epic hire all these famous Haskellers?</p>
<p><em>SPJ</em>: Oh I think probably the main connection is Tim Sweeney himself. So Tim Sweeney is the founder and CEO of Epic and he is a computer scientist and has been interested in programming for a long time. So he knows about Haskell and loves Haskell actually. So I think thatâs why he thought of people like me and Lennart and was keen to have us. But Verse isnât a Haskell clone by any means. Itâs a language that Tim has been designing sort of in his head actually for â I donât really quite know how long, I should ask him â around a decade. So itâs informed by functional programming and imperative programming and game programming and logic programming. Thereâs a lot going on in Verse. Lennartâs and my job is to sort of reverse engineer Verse out of timâs head and get it set down in a kind of formal semantics that everybody else can make make sense of.</p>
<p><em>AL</em>: And is it clear what Verse itself is going to be implemented in?</p>
<p><em>SPJ</em>: Oh. Almost certainly. So I would think C++ probably. I mean Lennart and I are busy implementing a reference interpreter of Verse in Haskell of course. But the whole games world is very C++ oriented, right? Theyâre very performance conscious. So I think the version that you first start to execute will certainly have a compiler thatâs written in C++. But who knows about the glorious future? Maybe itâll be written in Verse in the end?</p>
<p><em>AL</em>: So in terms of the day-to-day work, what does it look like working at Epic Games? Youâre still living in Cambridge?.</p>
<p><em>SPJ</em>: I will still be living in Cambridge, Iâm the only Epic employee living in Cambridge. So, one of the my losses in leaving Microsoft is not having an office and colleagues. But Iâm really happy to say that Pembroke College is appointing me as a visiting scholar for a year. So Iâm going to work out of Pembroke College in Cambridge. So I shall have a kind of perch in a Cambridge College which would be very nice. Iâll be able to meet astrophysicists and French linguists and medieval philosophers over lunch. So thatâs very exciting.</p>
<p><em>AL</em>: Yes, extremely exciting. Are they expecting anything in return like you giving lectures?</p>
<p><em>SPJ</em>: Iâm going to seek ways in which I can give back to the College in return for their generosity. We donât quite know what that will be but Iâm sure it will be fun. Because of Covid I havenât actually got there yet. So weâre still doing this conversation from home. But any moment now, I hope to move.</p>
<p><em>JB</em>: So is it refreshing to to work on an implementation of a language from scratch after having worked on this 20-30 years old codebase in GHC and all this big beast where you canât just redo everything from scratch?</p>
<p><em>SPJ</em>: Itâs a very different prospectus because in this case Verse is a pretty well-formed beast in Timâs head. If we want to do something different weâre going to have to persuade him but Iâm fine with that, right? But the dynamic is that heâs a sort of technical lead on the project â which is very unusual for the CEO of a multibillion dollar company and actually quite rewarding. So, in a sense, itâs everything from scratch but actually there is a team of a dozen or so people working on a compiler for at least a subset of Verse which would be the first thing that comes out. So Iâm learning at the moment, Iâm not going around redoing everything from scratch at all.</p>
<p><em>JB</em>: But the the interpreter youâre writing you get to write that from scratch.</p>
<p><em>SPJ</em>: Oh yes, yes.</p>
<p><em>JB</em>: I always find that writing something from scratch is easier and maybe also more more fun sometimes than modifying a 10000 lines of code compiler with a very picky performance test suite that makes you all makes every pull request go for weeks.</p>
<p><em>SPJ</em>: Yeah, thatâs true. So it is rewarding. Thatâs right, you can sort of, in an afternoon you can add lambda which is what I did this week to the other.</p>
<p><em>JB</em>: So maybe letâs twist the the question around to go back to Haskell: How could you stand working on something where you canât just add lambda in a day for these 2 decades on GHC? Doesnât it get on your nerve sometimes that there is just so much code that you would have to touch to make a change?</p>
<p><em>SPJ</em>: Oh, well, I donât think I feel that quite. So I find myself constantly frustrated by my own inability to manage complexity, right? I keep refactoring bits of GHC. The last few weeks have been rewriting parts of the the kind checker for data type declarations. Itâs quite complicated and Iâm trying to think there ought to be a simpler way to do this. And now I work quite closely with Richard Eisenberg and Sam Derbyshire and Ryan Scott on some of these kind of things. And weâre constantly trying to find the simpler simpler way to explain it and struggling with complexity. So itâs sort of the complexity that limits our ambition. So it isnât that the code is difficult to change, once you know what youâre going to do. So, one of the great things about Haskell actually, that is spoken about and I think itâs the sort of killer app for Haskell, is that itâs so refactorable, right? You can do a heart or lung transplant on GHC and make truly major changes and the type checker just guides you to do all the right things. The difficult stuff is envisioning and being very clear about what youâre trying to do. Actually doing it is often not that hard. But because it has become complicated, another frustration is that I very frequently have the feeling that I thought this was going to be simple but it turns out to be complicated, it turned out to involve more things than I had initially thought. And again I donât attribute that to the code, itâs a sort of complicated language thatâs trying to be quite ambitious now. But every time that happens, itâs a challenge. Well, could you write a paper about this that boiled out the sort of intellectual idea â what what was tricky here and how could we explain it in a better way? So itâs a constant drive to research.</p>
<p><em>JB</em>: So overall itâs not like thereâs a vision in your head that after 30 years if you would do a GHC from scratch there would be fundamental differences and you just canât get there because itâs too big? Or would you do something differently if you were to rewrite the implementation of Haskell from scratch?</p>
<p><em>SPJ</em>: I donât know. So some people have a big vision in their head that theyâre trying to reach towards. I actually think Tim Sweeney is like this. But with me and Haskell it hasnât really been like thati. Iâve never had a 10 year plan for Haskell. Itâs always been Iâve worked on the thing that seemed to be the most important or most interesting right now. Like the transactional memory came a bit out of the blue, that wasnât part of a big plan. Now, Stephanie and Richard have a big plan to make Haskell into a dependently type programming language. But weâve been moving pretty slowly on that, as you will have observed, because of all the things that Iâm very keen to keep. So if you like, Iâve almost become the rate limiting step on parts of Haskell and trying to say âletâs make sure that we donât lose touch with the the sort of the key bits that make Haskell goodâ. Which is that itâs a statically typed language that works fast enough to be usable in production. Letâs not make it so weird and sophisticated that we lose touch with scores of ordinary Haskell programmers. I think many Haskell programmers are quite extraordinary and write code that I canât make head or tail off. So this is one direction to travel. But I donât even know whether itâs the most important one. Maybe this project around the Haskell Language Server and making a better programming environment for building Haskell programs. Perhaps that will turn out to be more interesting and important in terms of spreading ideas. So maybe another way to say it is, in the end, the thing that Iâm really keen on doing, I suppose, is to bring more sort of evidence and substance to the idea that purely functional programming is a better substrate for the enterprise of constructing software than imperative programming. This is something I believe in. Itâs a hypothesis right? Itâs not necessarily true but I want to gather evidence for it. People have heardly me endlessly say <strong>âWhen the limestone of imperative programming is worn away, the granite of functional programming will be revealed underneathâ</strong>. But then we need to make that substantial and actual. So in a way the big message of Haskell, the big picture, the 10 year - 20 year vision, is not that it becomes super sophisticated but just becomes more widely used than appreciated â maybe not Haskell itself but the ideas of functional programming â and that people construct more beautiful, more elegant, more robust, more refactorable software in the future than they do today. Thatâs a bit of a sort of amorphous goal but I think itâs the big story arc of what Iâve been doing in my professional life, I suppose.</p>
<p><em>AL</em>: Usually we we ask our guests how they got into Haskell but in your case perhaps, how did you get into the position where you were at the right place at the right time so that you were around when Haskell started? I mean like how did you even like get into computer science in the first place and how did you become interested in Haskell?</p>
<p><em>SPJ</em>: Oh yes, so, how did I get computer science in the first place? That goes back a long way. So when I was at school I was clearly interested in computers but computing wasnât taught at school at all. The school I went to did have an IBM school computer. One of them! It had 100 memory locations into which, if you were careful, you could write a square root routine or game of nim but that was about it. I mean just 100 memory locations which are tasked to store both program and data. So I use that quite a bit, I had some really good friends at school who bounced off each other and learned a lot. The Intel 4004 came out around then â that was a 4 bit microprocessor for those who donât know. The very first sort of microprocessor that you could actually buy and build a computer of. Then a little while later they produced the 8008 which is an 8 bit microposeor. So it was just at the beginning of the time where you could get a microprocessor and solder it together with some memory chips and make something that worked, which I duly did when I was at um university. So kind of around that time it became clear that from when I was a teenager I kind of knew that I was going to stick with computing in some shape or form. But I didnât want to do it as a degree partly because it was difficult to find universities that did it as a degree because it wasnât really a respectable subject in those days. Cambridge didnât have a 3 year degree in computer science. You could do a 1 year final year course in it. So I chose to do Maths. But Maths turned out to be too hard so I left Maths after 2 years. Maths at Cambridge â thereâs a lot of scarily intelligent people. So I did engineering in my final year and then I did a postgraduate diploma in computer science. So, as it were I always knew I was going to end up in computing and somehow I didnât expect or want to be an academic. I didnât do a PhD, I left and got a job working for a small company. Then, rather by accident, landed out back in academia when I was starting to look for a new job and my sister said that there were some lectureships going at UCL. So I thought, well I just apply and see what happened, and, much to my astonishment, I was appointed as a permanent member of faculty with no PhD and one paper to my name. But your your question I think related then to Haskell. So, then then lots of serendipitous things happened. I knew I was interested in lazy functional programming. That arose from my time at Cambridge when I learnt from Arthur Norman and I was colleagues with John Hughes and Thomas Clarke and other people. So there was a little group of us who got the sort of functional programming bug. After I got a job as an academic I could then work on functional programming and there werenât that many people in the world who were working on particularly on lazy functional programming. So I was totally inspired by David Turnerâs papers on SK combinators - very short papers, anybody can read them, theyâre only 3 or 4 pages long. Theyâre completely inspirational because they suggested a completely different way of even thinking about executing functional programs. It was amazing, I still remember the thrill. So, there werenât that many people in universities working on functional programming languages particularly lazy functional programming languages. I started to get into the habit of going to the annual conferences: the Lisbon Functional Programming or Functional Programming Computer Architecture Conference in America. They were always in America at that stage. Then I did a 3 week tour in which I invited myself â I was very cheeky â I wrote to all these famous people â Arvind and Dan Friedman and Paul Hudak and so forth â âcan I come and just hang out with you for a day or 2 on my way out?â. So I did a three week tour around America staying with all these really cool people and that built relationships that led to forming the Haskell Committee. Because we got together at one of these conferences and said: âLook, weâre all doing lazy functional programming kind of things but we all have our own syntax, our own language. Thatâs a bit silly right?â. Because then we canât share code. Initially it was very very modest goal, it was letâs just share syntax, just have a common idiom for programming. How long, how hard can it be? Takes us about a month just to agree to the syntax. We already knew roughly what it was going to be like. So Miranda was around at that stage â David Turnerâs language. So it was going to be something like Miranda.</p>
<p><em>AL</em>: Miranda, if I remember correctly was primarily not chosen because of licensing issues?</p>
<p><em>SPJ</em>: Yes, we couldnât use Miranda directly because David Turner licensed it. We did ask him whether we could but it would have had to be on the basis that we could then grow and change it. And David for entirely legitimate reasons wasnât happy to do that. So we said âFineâ and we stayed on very friendly terms with David, but nevertheless designed a separate language. So itâs really just a group of us getting together at a conference saying âletâs get a common syntaxâ. Thatâs all it was, terribly low-key, terribly modest, will be done in a month.</p>
<p><em>AL</em>: So looking at it in retrospect, Haskell Committee had this really successful and, in my view, productive phase between, I think, roughly like the end of the 80s and the end of the 90s, where there was rapid evolution. I mean you said you set out with modest goals, but then actually lots of things happened and there were quite major like additions to the language that were not like previously in Miranda or any of the other languages that you set out to do. In particular, Iâm thinking about type classes and monadic I/O. Perhaps tying this to our current discussion about which direction the language should be going and major additions to the language such as dependent types or linear types and and the reception of these kinds of topics, how were the discussions going back in that day? Was it just everybody saying âwe finally have a great idea, letâs just put it inâ or was there a lot of controversy around these ideas?</p>
<p><em>SPJ</em>: I think it was pretty much the former actually. I still remember receiving Philâs message about type classes. So Phil sent a message to the to the Haskell Committee which was just a mailing list at the time. We did meet quite regularly in person, for a number of years. Iâm not quite sure how many years but we had several in-person meetings. Anyway, Phil sent us an email that contained this story of type classes including this sort of implementation plan with these dictionaries, all in one email. It was just amazing. He and Stephen Blott, his research student back then, turned that into the paper, the first paper about type classes. So at that stage it was uncontroversial in the sense that it met our need. We knew that we had a sort of a problem about how do we deal with parametric polymorphism but we still wanted to do equality and numerics. We didnât have a good way to do that. And we didnât really like MLâs way of these variables with tick marks on them and your arithmetic operations were sort of polymorphic, but had to be monomorphic at the usage site. So, type classes seemed to be âoh, hereâs a way of doing this kind of systematicallyâ. Since we had at that stage â going back to your question, Joachim â a language that didnât really have an implementation then we could morph, it seemed like âoh, this sort of feels right, letâs just do thisâ. So, there was very little debate about whether we should do it. It just seemed like âoh, yesâ. Another technical innovation that you didnât mention which I think as often goes unnoticed but is deeply profound is Haskellâs use of higher kinded type variables - type variables that can range over types, a type variable <code>m</code> that has king <code>Type -&gt; Type</code> or <code>* -&gt; *</code>. Now that was very unusual, right? ML has type variables that range over types, so to have type variables that range over type constructors was quite radical at the time. We were all worried about whether we need to do high order unification to do it. I think it was Mark Jones who demonstrated very convincingly and very quickly that you could get a long way with essentially still first order unification.</p>
<p><em>AL</em>: So whatâs the motivation for adding these? Was it to get <code>Monad</code> as a type class?</p>
<p><em>SPJ</em>: Well so that was that was the killer app, right? I donât think this was in the original Haskell, Iâm not remembering the chronology very well. But the killer for higher kinded type variables is that we could have a type class of <code>Monad</code>. So Phil Wadddlerâs paper about comprehending monads that first introduced to us the idea taken from Eugenio Moggiâs work that you could use monads as a programming idiom was a complete revelation to me at the time. But then to make it a programing idiom we could use over many monads you need this ability to abstract over higher kind of type variables. I canât remember the exact chronology but maybe it was one of those âmarriages made in heavenâ, you donât never quite know in which order things happened but it just fitted like a glove. I think it had a profound influcence on Haskell. Without the ability to abstract over higher kinded type variables Haskell would be a very different language. So that and type classes were both pretty significant innovations that happened with very little debate. As in they were not controversial. I think aspects of syntax were much more controversial: should Haskell enforce that you can reorder equations arbitrarily in a function definition? What should the exact definition the pattern matching be? What syntax did we use for lists and tupples and so forth? There were plenty of times debating those and we laughed at ourselves for that because we knew that in fact we appointed a syntax czar at any one moment to be the person who would ultimately resolve such things.</p>
<p><em>JB</em>: What is the worst syntax addition made by a czar that wasnât you?</p>
<p><em>SPJ</em>: Oh, I never mind very much about syntax. So, I was fine with all decisions actually.</p>
<p><em>JB</em>: Even when the syntax might have to change vertically? So, Iâm thinking of, coming back to the present day with this push towards dependent types, my impression is that nobody would mind dependent types and it could just come in if it werenât for the syntactic problems of lists and tuples. I mean thereâs a bit of a stretch, but the problem is that historically Haskell has a different time spaces so we can use the same symbols for the value of a tuple and the type of a tuple. But with dependent types when you want to have terms and types then this becomes very confusing. If you could magically just make this whole thing have one namespace, then the path would be clearer. The big obstacle on that path is certainly that we are very used to having the same syntax for built in things like tupples.</p>
<p><em>SPJ</em>: Yeah, so <code>[]</code>. You know, <code>[Int]</code> means list of int but <code>[3]</code> means a singleton list containing 3 and thatâs very different kind of thing. So, at the time, that didnât even pause right? We thought it would be so obviously helpful to use the same syntax for tuples as terms and tuples as types. Dependent types were not even on the horizon, I was certainly not thinking about them at all. I donât think we ever considered that to be a problem at the time and it is an obstacle now. But it is also convenient. So we got GHC proposals on the go at the moment for providing at least alternative syntax. It doesnât require this punning so you write <code>(Int, Bool, Char)</code>, I think thereâs a path that gets us there but if youâre not using dependent types it makes the language a little bit less convenient, maybe, but not much less. Maybe, with the benefit of hindsight, if weâd started off with <code>List</code> constructor instead of square brackets, maybe it would have made some things easier if weâd always done that.</p>
<p><em>JB</em>: Do you expect that the Haskell community will go along? I mean itâs superficial because itâs syntax but itâs also very a very deep change because it affects almost any code. Do you expect the community will go along or will this be a danger for having one Haskell community that has one language and lead to a fork in the road?</p>
<p><em>SPJ</em>: Well, itâs all behind language extension flags. I suppose you could imagine a future in which one group of people consistently used one set of language flags and another consistently used another and they couldnât really understand each otherâs programs. But actually, if you look at a program that uses lenses a lot itâs hard to understand if you have not got used to that library. It just is and thatâs nothing to do with the language, thatâs to do with libraries, right? Programs are always hard to understand if you donât understand the idiom in which itâs written. So I think itâs easy to overblow these syntactic things, I think theyâre probably relatively easier to adapt to than getting used to the dozens or hundreds of functions that you might want to use in a program that makes extensive users of lenses. I think is relatively superficial. So Iâm actually not too bothered about that.</p>
<p><em>AL</em>: Iâm wondering, youâve been working on GHC most of the time and GHC itself is relatively conservatively written right? But you have at the same time you have been implementing all these really cool extensions for Haskell that everybody is keen to use. Do you ever get to use them yourself in anything?</p>
<p><em>SPJ</em>: Oh, yeah, sure. So we have this sort of 2-release policy. We try to make sure that GHC can can be compiled with itself with two versions ago at least. But you wouldnât have much luck if you tried to compile GHC now with GHC 4.2. We do pull the ladder up after ourselves.</p>
<p><em>AL</em>: Thatâs true. But I guess youâre not using lots of GADTs, type families. Do you think you will be using linear types?</p>
<p><em>SPJ</em>: So we use a lot of type families. So I wrote the linear type paper and I think itâs extremely intriguing but I think itâs a hypothesis thatâs still out to bat as it were. We donât kind of know how it. Weâll have to see where the linear types things goes. I donât see any immediate reason or motivation for using linear types in GHC itself, at the moment. Quantified Constraints, I donât think we have any of those in GHC itself. We do have a lot of type families, though. By far the majority of them arise because weâre using this âtrees that growâ idiom. So thereâs another sort of library idiom that we know is embedded in a paper and weâre trying gradually to get GHCâs core syntax tree for Haskell into a form in which it could be completely detached into a standalone library and not have any GHC specific decorations at all. They all attach via these extension points which is not a built-in language feature but a sort of program in a programming idiom, but makes extensive uses of type families.</p>
<p><em>AL</em>: So in the beginning Haskell was formed around the idea of having a joint lazy functional programming language and then we talked about these major additions like type classes and monadic I/O and higher kinded type variables. I think already in this âHistory of Haskellâ paper youâre kind of making the points that, in retrospect, these things are to some extent more the essence of Haskell than laziness itself. Is that accurate?</p>
<p><em>SPJ</em>: Yes. Iâve been saying this for for many years now, I still love lazy functional programming but I donât see it as being Haskellâs most significant technical innovation. I think these other things are more important. Particularly, purity. Iâve often said that I think the most important thing about laziness is that it forces you to be pure, it makes it difficult for you to fall into sin and just say âletâs do a few side effects on the sideâ. So purity - super important, type classes - super important, monadic I/O - yes. Lazinessâ¦, well Haskell has lots of strictness annotations these days and strict functional languages generally have some support for laziness as well. So weâve sort of grown, from the ends towards the middle. It still feels a bit different programming in Haskell than it does programming in OCaml. But you could kind of do either in either, and I flirted frequently with the the idea of having an intermediate language in the compiler which is truly neutral to strict versus laziness. Weâre not still not there yet, but that would be a long-term aspiration to say it is truly neutral. It would be just as good for compiling a strict language, I donât think thatâs true of the of GHCâs Core language today.</p>
<p><em>AL</em>: Yeah I think itâs still a little bit of an unsolved problem. But I also feel like itâs always âthe grass is always greener elsewhereâ. So I mean Iâm mostly programming in Haskell myself obviously and Iâm also sometimes in a situation where I think âoh well, this laziness is just making everything more complicatedâ. But it doesnât take very long looking at some code written in an eager language where I say âwhy is it so complicated?â and then I figure out âoh, itâs because itâs not lazyâ. I think I would be equally unhappy if not more unhappy if I would suddenly be forced to switch to an eager language.</p>
<p><em>SPJ</em>: Yes, I could totally agree with you. I mean, people sometimes ask âif youâd design Haskell again would you make it strict?â and I think âmaybe I wouldâ. But then Iâm sure today Iâd be saying âIâd make it lazy.â</p>
<p><em>AL</em>: I mean that was where I was ending up. What would you be doing for the surface language? For the core language you would like it to be completely neutral. But if you could start from scratch with a new functional end user language, is there some compromise or would you still stick with lazier?</p>
<p><em>SPJ</em>: I donât actually know, itâs not as if I knew of a way of doing a sort of mixed functional lazy language that was somehow inaccessible to us because weâre so bought into the existing syntax and so forth. I donât think Iâd even start again with a strict language; I think Iâd pay might pay more attention to it earlier and maybe I would just for a change. Itâs a somewhat hypothetical question, because we are what we are with Haskell and building an edifice that large is, as we were discussing about, you need to be lucky as well as sort of cool and interesting. You know I think Haskell was very lucky in having sort of hit some kind of wave. Itâs difficult to repeat that.</p>
<p><em>AL</em>: I guess for Verse it would be too exotic to consider laziness?</p>
<p><em>SPJ</em>: Oh Verse is kind of lenient, actually. So things are evaluated eagerly but not strictly. So it has a lot of lazy flavor to Verse. Itâs not just a vanilla strict language at all. So Lenience is a term coined by Arvind and his colleagues at MIT about dataflow languages where everything gets executed but you donât have to wait for it to be done before you do the next thing. So in a dataflow machine if you called <code>f</code>, if you applied a function <code>f</code> to an argument expression <code>e</code>, it would spin off a computation to compute <code>e</code> and at the same time it would call <code>f</code> whereas in Haskell we build a thunk tree and only evaluate it if the function needs it. But in a dataflow machine, <code>e</code> was going to get evaluated sooner or later and maybe even after effort returned so thereâs this slightly strange property that they could still be humming even after theyâd printed the final answer.</p>
<p><em>JB</em>: Is that related to the work on speculative execution in GHC where there were attempts to be faster and use more parallelism by evaluating thunks even before they were used?</p>
<p><em>SPJ</em>: Yes, se we can certainly create a spark and if youâve got any spare processes hereâs something you could do. The idea was you could be free to start, but didnât have to. So, yes, itâs sort of related.</p>
<p><em>AL</em>: One of the things that I also particularly like about Haskell is that is the language that for over a long period of time has been used in academia and an industry and sometimes people are saying that creates a lot of tensions but I would overall personally say that itâs ultimately a really good thing. Did that in any way happen by design or did it just happen? I mean obviously originally it was an academic language and there is this famous âAvoid success at all costsâ that seems to indicate that at least making it particularly attractive for industrial use was never the goal. But at what point did it become an issue and at what point did you try to perhaps make active decisions in order to facilitate industrial adoption?</p>
<p><em>SPJ</em>: Well Haskell was always intended to be useful for real applications. And hereâs the Haskell Report, the very first one, which said goal number 1 âit should be suitable for teaching research and applications including building large systemsâ.</p>
<p><em>JB</em>: So I should explain to our listeners that Simon just reached to a shelf within an arm length and pulled it out in a moment. So he doesnât know it by heart but he has it right in there at his desk.</p>
<p><em>SPJ</em>: But I tell you this book, the Haskell98 Report has about a year of my life embedded in it as way too much work. I was the editor for that round of the report. It was the the first and only one that was published actually as a book. Well and thereâs a sort of PDF report.</p>
<p><em>AL</em>: Was it even in the preamble of the Haskell 1.0 report?</p>
<p><em>SPJ</em>: Yeah, in the preamble of the Haskell 1.0 report. It had those same words. Now of course that was a very aspirational thing to say. Usually programming languages are not nearly as successful as Haskell turned out to be. So I think weâre very lucky to have sort of caught some kind of way. And of course it does engender sort of tensions around the rate at which the language evolves and what we do about breaking changes. I suppose in the early days it was essentially the academics which clearly were in charge. Now, the bootâs rather on the other foot. We have this enormous regression suite for GHC, we have this big CI structure, we go through all these performance tests, we have the GHC steering committee to try to limit and control language and changes. And still our industrial users complain, quite legitimately actually, that things change too fast and that we just broken their code again and itâs too much work for them to to fix. But on the whole I see that this is a sort of creative tension right? If we work hard at resolving it then good things will come. I mean some things are just if your shoe is rubbing thatâs not a creative tension, it just hurts. But this is a sort of tension from which good things can grow if we pay attention to each other in a respectful way I think.</p>
<p><em>AL</em>: I also think itâs actually slightly more complicated right? I mean itâs not just the case that the academic users want to change Haskell all the time and the industrial users wanted to stay the same? I mean many of the biggest changes are at least partially driven by industry and some of the academics are sort of the most vocal in saying things should actually stay the same.</p>
<p><em>SPJ</em>: That is absolutely true. Iâve been quite stunned by the extent to which itâs an industry that some of these more exotic corners of the type system in particular are most widely used and I attribute that to the fact that in industry you want this code to still work in 10 years and be refactorable, you want to express intent and not just writing something that is going to be gone, here today and gone in a week like a sort of quick python script. They get the idea about expressing the intent in a type system. They really want to do it and then theyâre very annoyed if they canât. So quite a lot of these type system innovations have had a lot of driving force from industry. Like quantified constraints, for example: meeting Patrick from GitHub at a conference who said âSimon, I got one question: when are we going to get quantified constraints?â. I thought maybe 1 PhD student in a Scandinavian University would use this and hereâs a guy from GitHub who at that stage I didnât even know were using Haskell.</p>
<p><em>AL</em>: There are these kind of extensions that actually feel like they donât make the language more complicated but actually â and perhaps as an implementor â they do. But they actually make it more regular, for example, say the moment you introduce a higher kind of type variables that we talked about you basically need rank N polymorphism and at that point rank N polymorphism isnât really an extension in the sense that it is yet another completely new feature. It is something that follows natural from what you already have. And to some extent Quantified Constraints fall in the same category I guess.</p>
<p><em>SPJ</em>: Yeah, and kind polymorphism I definitely put into that category. If you say you know <code>data T f a = MkT (f a)</code> well of course it should be kind polymorphic and itâs ridiculous to choose 1 monomorphic instantiation of that.</p>
<p><em>AL</em>: So you often are taking, either deliberately or just because thatâs the way you are, sort of the role of a moderator to some extent. So like people are saying I want this, I want that and you often appear like youâre someone who basically is just listening to everybody and is just trying to find consensus and is trying to implement that and that makes you like well liked and respected by I think everyone in the community but is this something that you actively decided you want to do or is it really just like your character naturally?</p>
<p><em>SPJ</em>: Ah, well there are maybe 2 bits of this. Sort of late I spend more and more time reviewing code and reviewing design ideas from GHC proposals because Iâm surrounded with smart people whoâve got interesting ideas that they would like to put into GHC or Haskell. So that seems like a way that I can contribute to help refine those into a form in which they make sense. But in some ways itâs not quite as satisfying as doing it yourself. Nevertheless I do spend a lot of time in code review. And in fact, I often feel guilty because Iâm behind, I know there are people who waiting for me to look at their patch and that we really donât want to merge until I have had look at it. So I feel a bit embarrassed about that I donât have enough bandwidth. But maybe also referring to the fact that almost every paper Iâve written has been collaborative, I donât think this was a deliberate choice. It was more just the way that Iâve enjoyed working, is that Iâve met smart people and they have good ideas and I think âmaybe I can ride on this personâs coattailsâ. But then it turns out that I have a sort of useful role to play sometimes being the scribe rather than the moderator. Because writing papers distills out the essence of what a person has in mind, so thatâs why itâs really quite helpful. So yes, scribe I think is a good role.</p>
<p><em>AL</em>: Does it ever happen that somebody comes up with an idea where you say, at least like in the back of your mind, âoh no I really donât want this, I hope it never happensâ?</p>
<p><em>SPJ</em>: I donât think so. Itâs usually on the power to wait scale. Because Computer Science is factile almost ever everywhere you look you could discover something new, you can make something new. So it can be a bit âwell this is kind of interesting but will it give us enough payoff to devote all the cycles to developing it?â. So itâs mostly that. Iâm trying to think of any occasions in which Iâve come across anything I thought was an outright bad idea that I would not like to see and Iâm having trouble doing that actually. And probably even if I could I wouldnât tell you in public.</p>
<p><em>AL</em>: I think you have been rather skeptical initially about dependent types isnât that right? I mean at least skeptical, not not that you thought itâs a bad idea.</p>
<p><em>SPJ</em>: Skeptical. Itâs a skepticism born of having a brain of only moderate size? Thereâs something very deep and subtle going on there and, moreover, what I have discovered is that itâs not one thing right. Itâs not as if you say âoh letâs make Haskell dependently typed nowâ. The space of dependently typed programs is very large. Even if you get rid of the surface syntax, you just think of the internal language. So there was this project Stephanie Warwick and others ran about a language called Trellis. There was a sort of an intermediate language and they spent 3 years arguing with each other what that should look. Thereâs a big design space there and it always does my head in as well and so itâs essentially the sort of a limiting step. Can I actually understand it when I think that I thoroughly understand it that Iâm willing to at least consider having a go? Iâm quite reluctant to put anything to GHC that I genuinely donât understand at all. So I have been moving slowly on that. If you talk to Stephanie and Richard and so forth I think youâd probably hear them saying that itâs being a productive conversation that itâs not just that theyâve you know, finally driven me kicking and screaming to the brink there been a lot of refining thatâs going on.</p>
<p><em>AL</em>: I mean there are different aspects to dependent types, as you said so yourself. So one aspect is just to see it as a yet more powerful type system that makes you able to express yet more things more accurately. But the other thing is of course also that it that gets you closer to the realm of proof assistance and actually being able to reason about code formally and to possibly express things. Is that something where you think Haskell has a future in? Even though obviously, from a logical perspective, with everything being potentially non-terminating it is very difficult to prove reliable things within Haskell. But do you think that that is an interesting area that Haskell should also explore further for itself? For example, sort of in the direction of other approaches that are not dependent types or not exactly dependent types like Liquid Haskell or making use of SMT solvers and this sort of stuff?</p>
<p><em>SPJ</em>: My insict at the moment, for what itâs worth, is that we should move slowly with Haskell. Itâs got to stay a good programming language, right? That sort of reasoning cannot overwhelm the programming. One of the reasons that Iâm a bit cautious about dependent types is what I like doing is sort of lifting the restrictions. So when we added <code>TypeInType</code> â which was a big deal at the time, it kind of lifted up restrictions that made the kind system extremely limited before and now itâs just as much as the type system. Why should the kind system be sort of emasculated? Thatâs turned out to be quite useful. But a dependently type person would say âwell, you should just go the whole hog and make types and terms the sameâ. That has quite profound consequences that I donât feel that I am sort of fully ready to grapple with. But where I was going with this was one approach then is to say âletâs use dependent types more and more to specify what your program doesâ and another approach is to say âletâs do what Liquid Haskell does which is to take functions written in Haskell and then separately write a Liquid Haskell type that describes thatâ. At the moment my instinct is that that scales better because if I want to talk about a sorting function I want to say it returns a sorted list or list in ascending order or list of a certain length then what typically happens with dependent types is Iâm going to have to decorate the list with extra type parameters to describe say its length. That can clutter up all the functions that work over lists. Now, you know, <code>filter</code>, if you got lists with length, itâs got to return some kind of existential and we donât. So every time you use <code>filter</code> things have got a bit more complicated, maybe even significantly more complicated. Whereas the sort of Liquid Haskell story is to say âletâs do that part on the side as a separate reasoning processâ.</p>
<p><em>AL</em>: So you mean just the idea of writing types as refinement types is perhaps sort of more compatible with what we currently have?</p>
<p><em>SPJ</em>: Yeah. I donât want to infect the types like lists and list functions. I donât want them to get awfully more complicated in order for some aspects of reasoning like âis this list in ascending orderâ to be doable.</p>
<p><em>AL</em>: Yeah, okay. Just because you said âwrite separatelyâ and, of course, that is what you currently have to do with Liquid Haskell - you have to write one Haskell type signature and then you have to write another Liquid Haskell type signature. But in principle the LiquidHaskell type signature contains all the information that the Haskell type signature has. So I think in an ideal world, you would want to write only the Liquid Haskell type signature.</p>
<p><em>SPJ</em>: Maybe, but we quite a lot of duplicates when we write a function definition. You repeat the function name in every equation, right? You donât really need to do that. If youâve got repeated pattern matches you sometimes repeat parts of patent matches. We sometimes do use repetition because it makes the net result easier to understand. The one lovely thing about Haskell types is that a type itâs not too cluttered, it makes sense in itself: <code>Int -&gt; [a] -&gt; [a]</code>, I just sort of read that off. Now you could say, all that information is in some Liquid Haskell type that takes 3 lines to write down but the abstracted version is stilli important. Maybe in some programming environment that would show you the abstracted version as wellâ¦ now you know weâre talking again. But I really want to be able to see that obst abstracted version too.</p>
<p><em>JB</em>: Is there a a place for Liquid Haskell in GHC in the future or is that not being discussed.</p>
<p><em>SPJ</em>: Oh, mark my ambition! I would love Liquid Haskell to come in the box with GHC. Iâd just like it to be so well integrated and part of the programming environment that if you got GHC you automatically have Liquid Haskell. I think Liquid Haskell has quite a bit of engineering to do as in being used for real things. Itâs being used for real things by people with PhDs and that doesnât scale very well. The amazing thing about Liquid Haskell is we all talk about reasoning about Haskell programs but Liquid Haskell is actually doing it. And on real Haskell, right? Not on some toy subset of Haskell, because it uses GHCâs frontend. It can consume all of and really works on Core. It can work on all of Haskell. That is amazing, right? So, for me, thatâs as far as increasing our ability to give you statically guaranteed theorems about Haskell programs. My moneyâs on Liquid Haskell at the moment and I hope that we the Haskell community can sort of cohere around that because itâs such a big engineering effort to turn that kind of aspiration into reality. Itâs got to be more than just Ranyard and Nikki and a few others right? We all need to pile in there. Thatâs my brand leader for what itâs worth.</p>
<p><em>AL</em>: Yeah I agree. Weâve been partially working on turning Liquid Haskell into a GHC plugin which makes it a little bit easier to use but there is a lot of overhead and there is also some redundancy that is only needed between GHC and Liquid Haskell because there are separate tools in the first place.</p>
<p><em>SPJ</em>: Yeah Iâll be totally up for adapting GHC to fit. You know, itâs not an immutable thing. But when you start to do that you got to say âyes, we have critical mass behind Liquid Haskell, that means itâs not going to go awayâ. We just get left with a GHC thatâs got bent out of shape for now. No reason right. We need to make it as much a part of the ecosystem as GHC and Cabal and Stack and HLS.</p>
<p><em>AL</em>: Perhaps sort of towards the end, weâve already been talking about like dependent types and Liquid Haskell which are kind of current or future issues up to some extent. But weâve been also looking a lot into the past. So, are there things for the future of Haskell that you would wish or goals that you have for the language or major features that you wish somebody would implement or that you yourself still want to do?</p>
<p><em>SPJ</em>: I think my major goals at the moment are more social than technical. I mean of course Iâm noodling away all the time myself and Iâm fixing bugs and so, but as far as the big picture is concerned I think Haskellâs big and bigger sort of both vulnerability and opportunity is can we make things like the Haskell Foundation and the Haskell Community more broadly continue to work well? Itâs hard to scale when it was very small, itâs everybody knew each other, it was no problem. Then it became larger but still full of passionate motivated people and we sort of held together pretty well. Weâve had some incidents in the Haskell community that have not gone, all that well over the last 10 years or so. Now, the Haskell Foundation is the sort of big tangible initiative to try to help with that. And so I think my biggest sort of hope for the future is not some technical feature, is just that the Haskell Foundation in particular but really I mean the Haskell Community more generally can cohere in a way that makes all those fantastic people who I love so much work together in a way that means that they love and respect each other and prop each other up rather than they accidentally end up in fights. And then, if we can do that then that creates a context, a vehicle, a community from which all these creative and wonderful things can happen. Both technical things like the next great thing, maybe, but also the sort of the engineering stuff thatâs needed to turn something like Liquid Haskell into reality, and, perhaps.. I still want Haskell to be a laboratory in which great ideas grow and I donât quite know what those great ideas would be. But I think itâs unlikely weâve seen the last of them. I think everybody wants that â thatâs a good thing. Even our industrial users, they donât want their stuff to be broken that often but neither do they want stasis. People who want stasis probably have just switched to something else by now. Itâs that sort of socioechnical coherence and working together. Itâs not easy to achieve in a big geographically distributed community of people who very seldom meet each other in person. But I think we can do it I and Iâd like to play a part in making that happen.</p>
<p><em>AL</em>: Yeah, I think there are certainly some of these problems about changes that that have a technical solution but many of them need a social solution as well. And, do you have suggestions apart from just like being respectful to each other and doing, for example, what the Haskell Foundation is already doing? Do you have particular suggestions what we could all be be doing better in order to like collaborate better or particular things?</p>
<p><em>SPJ</em>: Ah, really I mean the thing that Iâve been thinking about a little bit recently is the pain that we go through when a new version of GHC comes out. It can be months or even years before libraries have caught up and and thatâs not because itâs hard to catch up. Itâs because library A which depends on library B has to wait for library B to work with GHC 9.2 before library A can even start work and then thereâs library X which depends on library A and X canât start work until library A done so that and that chain of dependencies makes things very slow and vulnerable to individual library authors, for absolutely legitimate and good reasons, being offline or away for a few weeks and. So I think itâs a sociotechnical problem. But I think maybe we can do something with Hackage overlays that would make it easier for people â not just the library authors, but for everybody â to muck in and just help do those routine changes that an author could then pick up and with a few mouse clicks could commit and release so that they didnât have to do the work and also other people didnât have to wait for them to do it. It could still make progress. I think if we can sort of identify what are the real problems â rather than just saying âthings break too oftenâ or âpeople arenât listeningâ say âletâs be tangibleâ, âletâs be concrete about what could helpâ. What is a problem and what could we do that would help? Iâm sorry thatâs not a very specific answer.</p>
<p><em>AL</em>: I donât think it was a very easy question. It was certainly a very vague question and I mean there are all these sort of things that can be partially at least improved by technical stuff. I think one of the recurring problem aspects in that space, for me, is still â I mean weâve been talking about this quite often: thereâs this lock between <code>base</code> and GHC. Because that creates implicit upgrade pressure and usually you can just say with libraries if I if Iâm unhappy with certain changes Iâll just not upgrade but by GHC being locked to <code>base</code>, if you want to have certain bug fixes at all, you need to upgrade all sorts of things, all sorts of dependencies. You need the latest thing, the latest security fix from one library but that suddenly comes along with a <code>base</code> dependency that requires a new GHC and therefore you need to upgrade GHC. And that means you need to upgrade all your other libraries as well. So this makes the whole thing much more serious in a way, whereas otherwise we could just say okay I disagree with this development but Iâm just going to stay roughly on this level for the next five years.</p>
<p><em>SPJ</em>: Yes, so I think what would help this conversation â itâs one thatâs actually taking place actively on the Haskell Discourse at the moment â, is to be quite specific about the chain of dependencies that you described, about use cases where where this goes wrong. Because one thing we could do, for example, which is being discussed on this third at the moment, is to try to split <code>base</code> into two: that is, you know a library thatâs really just the library that contains, for example, the I/O library â thereâs a lot of code there, thereâs 250 modules in <code>base</code>. They canât all be tightly coupled to GHC. Then thereâs a part that is pretty tightly coupled to GHC because itâs how do exceptions work or how does stack unwinding work or, you know, if weâre doing fold build fusion then that that is done with a sort of rule-based system but it lives in the one of the the most basic of <code>base</code> libraries. Iâm trying to think what else isâ¦ data types and classes that GHC itself knows about right? Then you canât just change <code>base</code> and and change one of those types if GHC has wired in knowledge of that type then you canât change. But there arenât that many of those right? So I think it would be significant work for someone maybe we could split <code>base</code> up. And then, if we split it up into a part that was really not coupled to GHC that would at least mean you could choose to use that library or not. But what I donât know is whether that would be a lot of work. Would that in fact, meet or help with the kind of problems youâre describing? Well weâd need to know. Quite a lot of specifics here. But so I think people like you can actually be really helpful here because I think from the GHC point of view weâd be totally willing to you know, cooperate with splitting up <code>base</code>. Weâre not sitting there saying âno, weâre definitely not going to do thisâ. We just need to know exactly what do you need, and will you help us do it?</p>
<p><em>AL</em>: Yeah I think one of the things that Iâve been observing is that already in the past weâve had these conflicting tensions. I mean some people say âI donât want my stuff to be in <code>base</code> because then itâs tied to GHCâ and other other people are saying âI absolutely want my stuff in <code>base</code> because then everybody has it and itâs available out of the boxâ. There have been, I think, some efforts to make <code>base</code> smaller over the years. There have also been, understandably, conflicting efforts to actually bring more stuff into <code>base</code> for exactly the reason that then you donât have to do any efforts to distribute it and you can rely on it being available everywhere.</p>
<p><em>SPJ</em>: Yes, so I think the message is that everyone is very open to concrete proposed solutions here, right? Itâs not that I donât think anybodyâs defending the status quo and saying itâs perfect as it is. Itâs just be specific about problems and preferably suggest ways to improve it. The only thing that sometimes makes me irritated about Haskell community is people whoâre simply criticizing â I mean from a legitimate point of view, Iâm saying the criticism is unjustified â but just that it it doesnât seem very actionable because I donât know what I can do to help that person.</p>
<p><em>AL</em>: Okay I think we should come to an end. Let me just use the opportunity to thank you again for taking so much time to talk to us about all these different things and wish you all the best for your future and exciting new adventures at Epic Games. Itâs good to hear that youâre going to be given time to continue to pay attention to Haskell and the future of Haskell and as well as telling us lots of new interesting things about Verse in the near future.</p>
<p><em>SPJ</em>: Iâve been having a lot of fun. I think both should be fun and I shall continue to be active in the Haskell community. Iâm happy to say itâs very generous of Epic to allow me to do that!</p>
<p><em>AL</em>: Absolutely. Thank you very much.</p>
<p><em>JB</em>: Good. Thank you.</p>
<p><em>SPJ</em>: Been nice talking to you both.</p>
    </div>
  </div>
  
</div>

    </div>

    <div class="max-w-screen-xl mx-auto text-center sm:px-12 md:px-12 lg:px-16 mt-32">
  <div class="font-bold">SPONSORS</div>

  <div class="mt-16">
    <div class="font-bold">Gold</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://iohk.io/" target="_blank" class="block w-48 m-4"><img alt="IOHK" src="../../assets/images/sponsors/iohk/iohk-683.png" srcset="../../assets/images/sponsors/iohk/iohk-200.png 200w, /assets/images/sponsors/iohk/iohk-400.png 400w, /assets/images/sponsors/iohk/iohk-683.png 683w"></a>
    
    <a href="https://juspay.in" target="_blank" class="block w-48 m-4"><img alt="Juspay" src="../../assets/images/sponsors/juspay/juspay_logo.png"></a>
    
    <a href="https://mercury.com/" target="_blank" class="block w-48 m-4"><img alt="Mercury" src="../../assets/images/sponsors/mercury/mercury.png"></a>
    
  </div>

  <div class="mt-16">
    <div class="font-bold">Silver</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://www.sc.com/en/" target="_blank" class="block w-36 m-4"><img alt="Standard Chartered" src="../../assets/images/sponsors/standard-chartered/scb-logo.png"></a>
    
    <a href="https://tweag.io/" target="_blank" class="block w-36 m-4"><img alt="Tweag" src="../../assets/images/sponsors/tweag/tweag-683.png" srcset="../../assets/images/sponsors/tweag/tweag-200.png 200w, /assets/images/sponsors/tweag/tweag-400.png 400w, /assets/images/sponsors/tweag/tweag-683.png 683w"></a>
    
    <a href="https://well-typed.com/" target="_blank" class="block w-36 m-4"><img alt="Well-Typed" src="../../assets/images/sponsors/well-typed/well-typed-683.png" srcset="../../assets/images/sponsors/well-typed/well-typed-200.png 200w, /assets/images/sponsors/well-typed/well-typed-400.png 400w, /assets/images/sponsors/well-typed/well-typed-683.png 683w"></a>
    
  </div>

  <div class="mt-16">
    <div class="font-bold">Bronze</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://www.channable.com/" target="_blank" class="block w-24 m-4"><img alt="Channable" src="../../assets/images/sponsors/channable/channable-683.png" srcset="../../assets/images/sponsors/channable/channable-200.png 200w, /assets/images/sponsors/channable/channable-400.png 400w, /assets/images/sponsors/channable/channable-683.png 683w"></a>
    
    <a href="https://www.digitalocean.com" target="_blank" class="block w-24 m-4"><img alt="DigitalOcean" src="../../assets/images/sponsors/digital-ocean/DO-logo-683.png" srcset="../../assets/images/sponsors/digital-ocean/DO-logo-200.png 200w, /assets/images/sponsors/digital-ocean/DO-logo-400.png 400w, /assets/images/sponsors/digital-ocean/DO-logo-683.png 683w"></a>
    
    <a href="https://opensource.google/" target="_blank" class="block w-24 m-4"><img alt="Google" src="../../assets/images/sponsors/google/google-683.png" srcset="../../assets/images/sponsors/google/google-200.png 200w, /assets/images/sponsors/google/google-400.png 400w, /assets/images/sponsors/google/google-683.png 683w"></a>
    
    <a href="https://qbaylogic.com/" target="_blank" class="block w-24 m-4"><img alt="QBayLogic" src="../../assets/images/sponsors/qbaylogic/qbaylogic-683.png" srcset="../../assets/images/sponsors/qbaylogic/qbaylogic-200.png 200w, /assets/images/sponsors/qbaylogic/qbaylogic-400.png 400w, /assets/images/sponsors/qbaylogic/qbaylogic-683.png 683w"></a>
    
    <a href="https://tripshot.com/" target="_blank" class="block w-24 m-4"><img alt="TripShot" src="../../assets/images/sponsors/tripshot/Tripshot_Logo_RGB.png"></a>
    
  </div>
</div>

<div class="mt-20 bg-gray-800 w-full py-20">
  <div class="max-w-screen-xl mx-auto text-gray-300 text-lg px-6 lg:px-16">

    <div class="flex flex-col space-y-8 text-center lg:flex-row lg:space-y-0">
      <div class="lg:flex space-y-4 lg:gap-2 lg:flex-grow lg:space-y-0">
        <div class="font-medium mt-1">To learn more about the Haskell Foundation </div>
        <div class="ml-2">
          <a href="../../contact" class="arrow-link light">>> contact us</a>
        </div>
      </div>

      <div class="flex space-x-4 w-44">
        <a href="https://twitter.com/haskellfound" target="_blank" class="text-4xl block"><span class="fab fa-twitter"></span></a>
        <a href="https://www.linkedin.com/company/haskell-foundation-inc" target="_blank" class="text-4xl block"><span class="fab fa-linkedin-in"></span></a>
        <a href="https://discourse.haskell.org/c/haskell-foundation/11" target="_blank" class="text-4xl block"><span class="fab fa-discourse"></span></a>
        <a rel="me" href="https://mastodon.social/@haskell_foundation" target="_blank" class="text-4xl block"><span class="fab fa-mastodon"></span></a>
        <a href="https://www.youtube.com/@HaskellFoundation" target="_blank" class="text-4xl block"><span class="fab fa-youtube"></span></a>
        <a href="https://github.com/haskellfoundation" target="_blank" class="text-4xl block"><span class="fab fa-github"></span></a>
      </div>
    </div>

    <div class="flex flex-row">
      <div class="mt-16 flex flex-col text-center flex-grow lg:flex-row lg:space-x-8 lg:space-y-0">
        <img src="../../assets/images/logos/hf-logo-100-alpha.png" class="h-8" alt="Logo of the Haskell Foundation" />
        <div class="font-medium">2025 Â© Haskell Foundation, <a href="https://github.com/haskellfoundation/haskellfoundation.github.io">submit website bug reports and fixes on GitHub</a></div>
      </div>

      <div class="text-sm mt-6 flex ml-8 flex-col justify-items-start text-left">
        <div>Haskell Foundation, Inc.</div>
        <div>2093 Philadelphia Pike #8119</div>
        <div>Claymont, DE 19703</div>
        <div>USA</div>
      </div>
    </div>

  </div>
</div>

  </div>

</body>

</html>
