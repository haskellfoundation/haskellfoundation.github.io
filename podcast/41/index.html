<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="76x76" href="../../assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="../../assets/favicon/site.webmanifest">
  <link rel="mask-icon" href="../../assets/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!-- other -->
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" data-ssr name="viewport">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Maven+Pro:wght@400;500;700&family=Playfair+Display:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/all.css" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/regular.css" rel="stylesheet">
  <link href="../../assets/fontawesome-free-5.15.2-web/css/brands.css" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/css/main.css">
  <link rel="alternate" type="application/rss+xml" href="https://feeds.buzzsprout.com/1817535.rss">
  <script src="../../assets/js/main.js" defer></script>
  <!-- from https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/62154131#62154131
        attempt to fix: https://github.com/haskellfoundation/haskellfoundation.github.io/issues/70
  -->
  <script>
    if (navigator && navigator.serviceWorker && navigator.serviceWorker.getRegistration) {
      navigator.serviceWorker.getRegistration('/').then(function(registration) {
        if (registration) {
          registration.update();
          registration.unregister();
        }
      });
    }
  </script>

  <!-- metadata -->
  <title>Moritz Angermann</title>
  <meta property="og:title" content="Moritz Angermann">
  
  <meta property="og:description" content="Today, MatthÃ­as and Joachim are interviewing Moritz Angermann. Moritz
knew he wanted to use Haskell before he knew Haskell, fixed
cross-compilation as his first GHC contribution. We'll talk more about
cross-compilation to Windows and mobile platforms, why Template Haskell
is the cause of most headaches, why you should be careful if your sister
calls and tells you to cabal install a package, and finally how we can
reduce the fear of new GHC releases, by improving stability.
">
  

</head>

<body class="relative">

  <!-- This is the mobile fly-out menu - outside document flow. -->
  <div id="nav-backdrop" class="fixed z-10 inset-0 hidden"></div>

<div id="mobile-nav" class="fixed z-20 top-0 right-0 w-full sm:w-1/2 max-h-full overflow-auto hidden rounded-b shadow-lg bg-white px-4">

  <div class="pt-6 flex justify-between">

    <div>
      <img src="../../assets/images/logos/hf-logo-100-alpha.png" width="68" height="52" alt="Logo of the Haskell Foundation" />
      <div class="text-sm mt-2 text-gray-500">The Haskell Foundation</div>
    </div>

    <div class>
      <button id="mobile-nav-close" type="button" class="inline-flex items-center justify-center p-2 rounded text-purple-800 shadow-lg focus:outline-none">
        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

  </div>

  <div class="mt-6">
    <a href="../../" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Home</a>

    <div class="block py-3 border-t border-gray-320 text-lg font-medium text-gray-500">About</div>
    <a href="../../who-we-are" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Current Board</a>
    <a href="../../who-we-are/past-boards" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Past Boards</a>
    <a href="../../contact" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Contact</a>
    <a href="../../vision" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Vision</a>
    <a href="../../careers" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Careers</a>

    <a href="../../podcast" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Podcast</a>

    <a href="../../projects" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Projects</a>

    <a href="../../donations" class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Sponsorship</a>

    <div class="block py-3 border-t border-gray-320 text-lg font-medium text-gray-500">Affiliates</div>
    <a href="../../affiliates" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Affiliates</a>
    <a href="../../affiliates/about" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">About Affiliating</a>

    <div class="block py-3 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium text-gray-500">News and Info</div>
    <a href="../../news" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">News</a>
    <a href="https://haskell-foundation.medium.com/" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Blog</a>
    <a href="../../news/press" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Press</a>
    <a href="../../resources" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">Resources</a>
    <a href="../../faq" class="block py-3 pl-6 border-t border-gray-320 hover:bg-gray-100 text-lg font-medium">FAQ</a>

  </div>

</div>


  <!-- Document flow begins here -->
  <div class="min-h-screen flex flex-col">
    <div>
      <nav class="max-w-screen-xl mx-auto px-4 pt-6 sm:pt-12 sm:px-6 flex items-center justify-between justify-self-stretch">

  <div>
    <a href="../../">
      <img src="../../assets/images/logos/hf-logo-100-alpha.png" alt="The Haskell Foundation homepage" />
      <div class="text-sm mt-2 text-gray-500"></div>
    </a>
  </div>

  <nav class="hidden lg:block">
    <ul class="flex space-x-8 xl:space-x-12">


      <li class="relative">
        <a href="../../who-we-are" id="who-we-are-nav-item">About</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="who-we-are-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../who-we-are">
            Current Board
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../who-we-are/past-boards">
            Past Boards
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../contact">Contact</a>


          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../vision">Vision</a>
          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../careers">Careers</a>
        </div>

      </li>

      <li class="relative">
        <a href="../../podcast">Podcast</a>
      </li>

      <li class="relative">
        <a href="../../projects">Projects</a>

      </li>

      <li class="relative">
        <a href="../../donations">Sponsorship</a>

      </li>

      <li class="relative">
        <a href="../../affiliates" id="affiliates-nav-item">Affiliates</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="affiliates-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../affiliates">
            Affiliates
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../affiliates/about">
            About Affiliating
          </a>

        </div>

      </li>

      <li class="relative">
        <a href="../../news" id="news-nav-item">News and Info</a>

        <div class="pt-2 absolute top-full w-44 bg-white shadow-md z-10 hidden" id="news-nav-item-menu">

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../news">
            News
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="https://haskell-foundation.medium.com/">
            Blog
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../news/press">
            Press
          </a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../resources">Resources</a>

          <a class="block p-4 border-t-2 hover:bg-gray-50 cursor-pointer" href="../../faq">FAQ</a>
        </div>

      </li>

    
      <li class="relative">
          <a class="dbox-donation-page-button" href="https://donorbox.org/donation-button-52?" style="background: rgb(94, 80, 134); color: rgb(255, 255, 255); text-decoration: none; font-family: Verdana, sans-serif; display: flex; gap: 8px; width: fit-content; font-size: 16px; border-radius: 5px; line-height: 24px; padding: 8px 24px;"><img src="https://donorbox.org/images/white_logo.svg">Donate</a>
      </li>
    </ul>
  </nav>

  <div class="absolute right-0 lg:hidden self-start">
    <button id="mobile-nav-open" type="button" class="mr-4 flex items-center justify-center p-2 rounded text-purple-800 shadow-lg focus:outline-none" aria-label="Main menu" aria-haspopup="true">
      <svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
      </svg>
    </button>
  </div>

</nav>

    </div>

    <div class="flex-grow">
      <div class="max-w-screen-xl mx-auto py-16 md:py-24">
  <div class="sm:px-6 lg:px-16">
  <div class="relative">
    <div class="absolute top-0 left-0 border-t border-l border-purple-50 h-10 md:h-20 w-10 md:w-20">
      <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-100 h-10 md:h-20 w-10 md:w-20">
        <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-200 h-10 md:h-20 w-10 md:w-20">
          <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-300 h-10 md:h-20 w-10 md:w-20">
            <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-400 h-10 md:h-20 w-10 md:w-20">
              <div class="absolute top-1 md:top-2 left-1 md:left-2 border-t border-l border-purple-500 h-10 md:h-20 w-10 md:w-20"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="absolute top-0 right-0 border-t border-r border-purple-50 h-10 md:h-20 w-10 md:w-20">
      <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-100 h-10 md:h-20 w-10 md:w-20">
        <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-200 h-10 md:h-20 w-10 md:w-20">
          <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-300 h-10 md:h-20 w-10 md:w-20">
            <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-400 h-10 md:h-20 w-10 md:w-20">
              <div class="absolute top-1 md:top-2 right-1 md:right-2 border-t border-r border-purple-500 h-10 md:h-20 w-10 md:w-20"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="text-center pt-12 md:pt-20 px-12 sm:px-16 md:px-24 lg:px-36 ">
    <h1 class="text-2xl-5xl"><b>41</b> â Moritz Angermann</h1>
  </div>
</div>

<div class="max-w-screen-xl mx-auto">
  <div class="mx-auto prose md:prose-lg">
    <div class="space-y-8 max-w-2xl my-7 mx-auto">
      
      <p><em>Recorded 2023-12-11. Published 2024-01-15.</em></p>
      
      <p>Today, MatthÃ­as and Joachim are interviewing Moritz Angermann. Moritz knew he wanted to use Haskell before he knew Haskell, fixed cross-compilation as his first GHC contribution. Weâll talk more about cross-compilation to Windows and mobile platforms, why Template Haskell is the cause of most headaches, why you should be careful if your sister calls and tells you to cabal install a package, and finally how we can reduce the fear of new GHC releases, by improving stability.</p>
    </div>
  </div>

  <div class="mx-auto prose md:prose-lg my-6">
    <div id="buzzsprout-player-14310617"></div>
    <script src="https://www.buzzsprout.com/1817535/14310617.js?container_id=buzzsprout-player-14310617&player=small" type="text/javascript" charset="utf-8"></script>
  </div>

  
  <div class="mx-auto prose md:prose-lg my-6">
    <div class="flex items-center space-x-4">
      <!--
       TODO: Insert nice icon
       <div>
         <img class="h-10 md:h-16 lg:h-20" src="/assets/images/affiliated.svg" alt="">
       </div>
       -->
      <h2 class="text-2xl font-normal">Related links</h2>
    </div>
    <div class="border-l-3 border-gray-300 ml-5 md:ml-8 lg:ml-10 pl-4 md:pl-8 lg:pl-14 pr-4">
      <ul>
<li><a href="https://medium.com/@angerman">Moritzâ blog</a></li>
<li><a href="https://input-output-hk.github.io/haskell.nix/">haskell.nix</a></li>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/wip/general-rules/principles.rst">Stability proposal</a></li>
<li><a href="https://www.mobilehaskell.org/">mobilehaskell.org</a></li>
</ul>
    </div>
  </div>
  

  
  <div class="mx-auto prose md:prose-lg my-6">
    <div class="flex items-center space-x-4">
      <!--
       TODO: Insert nice icon
       <div>
         <img class="h-10 md:h-16 lg:h-20" src="/assets/images/affiliated.svg" alt="">
       </div>
       -->
      <h2 class="text-2xl font-normal">Transcript</h2>
    </div>
    <div class="space-y-8 max-w-2xl my-7 mx-auto">
      <em>This transcript may contain mistakes. Did you find any?
      <a href="https://github.com/haskellfoundation/haskellfoundation.github.io/edit/hakyll/podcast/41/transcript.markdown">Feel free to fix them!</a></em>
    </div>
    <div class="border-l-3 border-gray-300 ml-5 md:ml-8 lg:ml-10 pl-4 md:pl-8 lg:pl-14 pr-4">
      <p><em>Joachim Breitner (0:00:15)</em>: Today on the Haskell Interlude, Matt and I are joined by MoritzÂ Angermann. We talk about the challenges of cross-compiling Haskell and the headaches that Template Haskell causes there, the need for a GHC stability regime, and why you should be careful if your sister calls and tells you to install a certain cabal package.Â </p>
<p>Good evening, Moritz. Good to have you on the show. How did you get into Haskel originally? What made you be here in the long run?</p>
<p><em>Moritz Angermann (0:00:45)</em>: Well, thank you for having me. How did I start with Haskell? So, Joachim might know this. There used to beâwell, there still isâa mobile application in Germany called Outbank. Theyâre doing multi-banking, where you can basically have your bank accounts across multiple banks aggregated in one application that downloads your statements from the banks and then gives you a unified view. So, after university, a colleague of mineâwell, a friend basicallyâstarted working for that company, and then they needed some help doing mobile application development. So, I joined that company as well, and eventually I was like, âIâd really like to do most of this in Haskell,â because weâre doing financial stuff and I basically want to have more assurance around what we actually do. So, I was like, âOkay, letâs learn Haskell, and letâs try to figure this out.â</p>
<p><em>JB (0:01:34)</em>: Wait, you said you went there saying, âI want to do this in Haskell.â And then the next step was, âOkay, what is this Haskell in the first place?â</p>
<p><em>MA (0:01:43)</em>: Yes. That was the thing. So, there was another friend from university who unlike â so, I studied mathematics, and the other friend studied computer science, and he just talked about Haskell occasionally, like more assurances and whatnot. So, I had a lot rough idea of what Haskell was, but thatâs about it. And we did lots of Objective-C and then later Swift stuff. At that company, we was like, âWell, I think we can take this a notch further.â And then I tried to figure out, âOkay, how can we do Haskell?â And thatâs when I started figuring out that we actually canât. Thereâs absolutely no way Haskell can do any of that. We may be able to build a library for x86, and thatâs basically it.Â </p>
<p><em>JB (0:02:26)</em>: So, this is thinking about client-side software, not server-side software.</p>
<p><em>MA (0:02:30)</em>: Yes. So, the whole â so, Outbank, even today, I believe, is mostly client side. So, one thing that drew me to the company was that they focused on privacy first, which meant nothing ever left your device. Everything was on device.Â </p>
<p><em>JB (0:02:42)</em>: VeryÂ German.</p>
<p><em>MA (0:02:43)</em>: We even had some cloud sync developed, which basically, the encrypted synchronization between your own devices, but there was no server involved, which also meant we never had any user data, which for any form of valuation is always a bit hard because people like to have user data. But we didnât have any for good reasons. So, yeah, it was always client side. I was like, âOkay,â trying to figure that out. And I figured, âWell, thatâs not going anywhere.â But that meant I was still looking at the Haskell and trying to figure out how to actually make it work at some point. So, that was when I basically started to work on Haskell, trying to make a cross-compiler without actually having any Haskell code. A cross-compile, just like, okay, if I want to use this, I need to make it usable for mobile. And thatâs how this started.Â </p>
<p><em>JB (0:03:26)</em>: What year are we roughly talking about, just to put it in historical perspective, or of its GHC version, if thatâs more easy to remember?</p>
<p><em>MA (0:03:34)</em>: I donât even remember the GHC version. So, Austin was still running GHC, basically. We still had Fabricator. Reid Barton was there. So, 10 years ago. A bit more than 10 years ago.Â </p>
<p><em>JB (0:03:50)</em>: Okay.</p>
<p><em>MA (0:03:51)</em>: Well, I guess we could look up when my first commits were to GHC because that was about right around that time. So, I started Haskell working on GHC. It might not be the most common thing, but â</p>
<p><em>JB (0:03:59)</em>: No, probably not.Â </p>
<p><em>MA (0:04:00)</em>: Well, thatâs what I wanted to do. So then, I figured out, okay, even if I can compile parts of â well, I mean, you could build a cross compiler and then build parts, but soon you hit like any form that uses Template Haskell or anything, and youâre like, âOkay, this is not going anywhere.â I was like, âHmm, but thereâs a compiler that can do Template Haskell.Â How does that one do it?â So, I talked toÂ LuiteÂ quite a lot and tried to figure out how do we actually get this done in GHCJS. And thenÂ LuiteÂ told me how that worked. I was like, âOkay, how do we graph this onto GHC?â And to be fair, I had no idea what I was really doing. I was just trying my best to get anywhere. And it didnât really go anywhere at that time. And was like, âOkay, maybe we can at least change this LLVM backend we have into a slightly better one because at that time we still had this issue that LLVM, which each version changed its textual format. So, GHC was basically tied to one LLVM version. And that really needed to be the same, because the next one might just break the format. And LLVM has a binary-compatible format. So, the bitcode backend, which around that time also got pretty popular for Apple because they had this idea that developers maybe just publish bitcode-based applications. They could just recompile them on their servers for either optimizations or different targets. That seems not to have pan out. I hadnât heard about bitcode for Apple a long time ago. They certainly had this idea. So, I was like, âOkay, maybe I can write a bitcode backend.â And then I worked on that. That code is still on my GitHub and even gave a lightning talk in â I think it was Nara during ICFP.Â </p>
<p><em>JB (0:05:42)</em>: I think I remember that.</p>
<p><em>MA (0:05:42)</em>: So,Â I could get it to work but not perform it enough to compile fast enough. So, probably with some space leaks, and I never really followed up on it. So, time continued. I was still working on like, okay, LLVM doesnât change so much, and we can still use the regular LLVM textual backend we have and use that. And then I just will try making stuff work occasionally. At that point, the company I worked for, Outbank, basically imploded. I lost my job, and we moved to Singapore during that time anyway. I was like, âOkay.â</p>
<p><em>JB (0:06:17)</em>: We being not the company that imploded, but rather â</p>
<p><em>MA (0:06:20)</em>: My wife and I. So, it was like, okay, I donât have a job, and I really want to get this cross-compilation thing going. So, I started writing a blog post and basically published every few days things on building, cross-compiling Haskell, and whatnot. Then a new company came and said, âHey, if you can cross-compile to mobile, maybe you can cross-compile to Windows, because Windows in CI sucks so much. We really, really donât want to compile to Windows.â I was like, âSure, why not? Letâs try. Iâve never tried it, but we can do.â Thatâs when I basically started at, back then, IOHK and started building Windows cross-compiler for Haskell so we could basically compile the flagship product of the company to Windows without actually using Windows.Â </p>
<p>Since then, Iâve been at the same company, doing mostly cross-compilation and primarily develop experience topics for GHC. And large parts of that is also building for ARM and for static binaries, because ultimately just building a static binary is so much easier to distribute. So, you can treat Windows and other platforms just as basically deployment targets and then ignore it. Thatâs basically how that went.</p>
<p><em>JB (0:07:30)</em>: I looked it up. Your first commit to GHG was on October 21st, 2014. So, itâs nine years old, and it has the title âFixes the ARM build,â which is a pretty impressive first commit for somebody who just learned Haskell, and then they go into GHC and â well, theyâve fixed the ARM build and â</p>
<p><em>MA (0:07:48)</em>: Well, GHC is mostly C to large parts, at least the part that I usually double, and itâs like lots of the RTS and backend.Â </p>
<p><em>JB (0:07:55)</em>: Yeah. But still â the third commit that I see is âUpdate Readme.md,â which is like the usual first commit or somebody makes where they come in and they dare to change a little bit of the documentation. But you went in all the way. Thatâs very impressive.</p>
<p><em>MatthÃ­as PÃ¡ll Gissurarson (0:08:10)</em>: So,Â you were targeting ARM. Before, the Macs were all ARM, so â</p>
<p><em>MA (0:08:17)</em>: Yes. Way before. iPhones were ARM, right? And then all the Android devices are basically also ARM. I mean, there was MIPS, and then thereâs a few AArch64Â ones, but itâs mostly ARM. And Googleâs now apparently also starting to move towards RISC-VÂ and â well, we can get to RISC-VÂ later. Thatâs how that basically happened. And I just remember the first few reviews in Fabricator were pretty rough. Also did a pretty good job in making sure not too much bad code got in.</p>
<p><em>JB (0:08:47)</em>: Okay. Was it only rough in terms of tactical content or also in terms of welcoming a new contributor?</p>
<p><em>MA (0:08:55)</em>: I donât remember that. I think it was like, well, I think we need a test and something else, and yeah. So, I just remember, well, quite a bit of rigor around getting stuff into GHC, which probably wasnât bad, but I got that done. And during that time, I basically learned to love Fabricator, and I still like it today because it has this view where you basically look at your change set and you just ignore the commits in between. Itâs still a way I work today, even though GitHub tries to work against me.</p>
<p><em>JB (0:09:25)</em>: What do you mean ignore the commits?</p>
<p><em>MA (0:09:27)</em>: Well, commits is just how you structure your code, right? But the commits itself are irrelevant.</p>
<p><em>JB (0:09:34)</em>: Right. But isnât that the default view on GitHub where you have just the changes of all the changes of your pull request?Â </p>
<p><em>MA (0:09:38)</em>: Yes. But Fabricator very nicely gives you like, show me the diffs to the previous state. So, you viewed the base against your last changes.Â </p>
<p><em>JB (0:09:48)</em>: Oh, you mean like when GitHub users would force push and then itâs confusing and everybody has a bad time?</p>
<p><em>MA (0:09:53)</em>: And otherwise, you also would need to view the last commit instead of like, show me the diff against the last view I reviewed. That helps a lot because then you donât start reviewing. So, like, what the hell happened? Itâs also how I treat most of my produce. Basically just squash merge all the time.Â </p>
<p><em>JB (0:10:12)</em>:Â Same here.</p>
<p><em>MA (0:10:12)</em>: I think commits are ways to structure how you do your work, but ultimately, itâs just one change that hopefully is properly described. And I also donât like changes that are way too large. And so, Iâd rather have every change be in itself meaningful and not like these long-lived branches, like lots of commits, and then just try to merge them somehow into the main brand.</p>
<p><em>JB (0:10:35)</em>: Yeah. Or the other extreme where you have a long-lived branch and then you spend so much time on rebasing the commits into a synthetic â this is how it could have come to be if I knew everything ahead of time, which you then very proudly emerged into master using rebase because youâre so proud of your separately divided commits and nobody ever cares about it anymore, because you hardly ever look at the history and just by squash merging it to save â just avoid the distraction.</p>
<p><em>MA (0:11:01)</em>: Well, the thing is, I find rebase often not really work the way I want it to work. So, what I end up doing is basically just generating patches and then applying those</p>
<p><em>JB (0:11:10)</em>:Â Kind of old school. Thatâs very old-school.</p>
<p><em>MPG (0:11:12)</em>: Nice.Â </p>
<p><em>MA (0:11:13)</em>: But yeah, I remember having long rebase basically change sets on top of change sets in GitLab. And then when Haskellâs built, it just takes two days until your PR maybe compiles once. And everything is in between getting invalidated. And then you rebase, and you have to rebase the ones on top. It takes days again, and youâll basically, âOkay, I spent a week just trying to get these few changes into GHC. That just canât work,â which is also when I start basically saying, âOkay, I canât take this. Iâm just going to buy a few machines and just run CI for GHC because thatâs just not sustainable.â I mean, at that point, I had a few people working at IOG that also worked on GHC and was like, âI just canât make this work in any form with GHC. Itâs so slow.â So, I was like, âOkay, itâs not that much of my personal money. I just spend it on CI-built machines and at least get us moving forward.â And then later it was like, âOkay, maybe we can have some form of way to finance that.â That never really worked out. I mean, Iâm very grateful to the Cardano Foundation to support the stake pool Iâm running with quite a large chunk, but there are not that many people that actually support that stake pool to make it really viable without the Cardano Foundation.</p>
<p><em>JB (0:12:26)</em>: But that sounds like GHC development is quite a pain. Has this improved since you had to experience that pain, or is it still the same?</p>
<p><em>MA (0:12:35)</em>: I donât know. I guess Sylvain would be a better person to ask because I ended up doing a lot more on the haskell.nix side and on management side, andÂ SylvainÂ is doing most of our GHC development these days.Â </p>
<p><em>JB (0:12:48)</em>: Okay.</p>
<p><em>MA (0:12:49)</em>:Â I hope it has improved, but yeah, I canât say if it definitely has. I think we got build times down quite substantially.</p>
<p><em>JB (0:12:58)</em>: And indeed, your last commit is, from two years ago, âDo not sign extend CmmIntâs unless negative - might fix,â and then a number.Â </p>
<p><em>MA (0:13:07)</em>: No, there should be one from âÂ </p>
<p><em>JB (0:13:08)</em>: Maybe that my checkout is old. Oh, that could be.</p>
<p><em>MA (0:13:10)</em>: There should be one from like a week or two ago removing some old Xcode nonsense.</p>
<p><em>JB (0:13:15)</em>: Okay. Yeah. I wouldnât have that. So, coming back to bringing Haskell onto the client side/mobile side when it wasnât there, cross-compilation is, of course, one part of it, but all naively, I would expect that you donât want to run the command line tool on your phone.Â </p>
<p><em>MA (0:13:31)</em>: No.</p>
<p><em>JB (0:13:32)</em>: So, how do you approach that? How do you make a GUI app that looks usable for users across different mobile phones?Â </p>
<p><em>MA (0:13:42)</em>: Well,Â itâs the same with what â so, if you look at quite a few of the iOS and other applications today, they often have some form of either C++ or some other language cores, and then a platform native Chrome on top, which is like you write your platform native UI in Swift or Kotlin or what have you. And then for significant business logic, you delegated some C++ library. C+ is very popular because, well, the whole toolchain work of C+ is fairly reliable in at least the build side of things, and it also just exposes some form of C API you can then integrate.</p>
<p><em>JB (0:14:14)</em>: But did you look into ways of doing a fully Haskell client, or was it just out of the question?</p>
<p><em>MA (0:14:21)</em>: I never really thought about using Haskell much for UI. I mean, we do have reactive frameworks on Reflex, comes to mind others, but to me, thatâs always like a problem is solved after we have solved the fundamental one of getting Haskell well onto that platform. If you can have the Haskell core and then just the UI Chrome, which is often also the part thatâs much easier to write in the platform native language. And I donât want to spend too much time on like, âOh, maybe we can make this work.â Then we should spend hours and days and whatnot to make it work, which is, maybe can use the platform native and use Haskell for the important part where we say, âOkay, we can use the properties of Haskell we want. We can use more formal methods like approach to defining how our business logic should work and have these assurances in our software.â At least in the business logic side of things of our core library, then yeah, thatâs what we should do and focus on UI using the platform native toolkit.</p>
<p><em>JB (0:15:18)</em>: Yeah. Totally makes sense.Â </p>
<p><em>MA (0:15:19)</em>: And even if we look at desktop apps today, you see them having basically a browser in some form of backend that they delegate you. Itâs a very popular approach, which I find a bit resource-intensive, but ultimately, businesses pay for solutions not for technical marvels.</p>
<p><em>JB (0:15:36)</em>: Thatâs unfortunate in a way.</p>
<p><em>MA (0:15:37)</em>: It is. But thatâs just the reality. I mean â</p>
<p><em>JB (0:15:40)</em>: Yeah, no, no, it makes sense.Â </p>
<p><em>MA (0:15:41)</em>: Ultimately, we want to solve problems and not spend too much money on making these problems. I donât know ideologically correct or however youâd like to frame that.Â </p>
<p><em>JB (0:15:50)</em>: But then even more interesting that you got to do this whole âletâs fix Haskell cross-compilation and use it in our clientsâ stuffâ because at least from, I guess, our point of view, certainly the technical marvel.</p>
<p><em>MA (0:16:01)</em>: Right. But that only works because we needed to do Windows, and Windows in CI was just so goddamn annoying. If you just can build on Linux, itâs so much easier.Â </p>
<p><em>JB (0:16:09)</em>: But thatÂ doesnât justify Haskell yet, does it? I mean, you could cross-compile C to Windows.</p>
<p><em>MA (0:16:13)</em>: Right. Right.</p>
<p><em>JB (0:16:14)</em>: So thereâs still something. We had to convince somebody that Haskell is really more than just technical marvel that nerdy people with math friends â or no, you were the math person with computer science friends â want to do.Â </p>
<p><em>MA (0:16:25)</em>: Well, luckily, that was not my job. That was already set in stone before I started embarking on this. So, people had decided they wanted to use Haskell and then they were like, âOkay, but we donât really want to use Windows and we donât want to manage Windows in CI and whatnot, so can we do something about that?â And thatâs how that basically happened. And from there, I was just like, âOkay, if we have built this infor â so, when we started, I was â okay, one step back. I was hired and was told weâre going to use Nix to do this. I was like, âNix is what? I never heard Nix. What the hell is this? Okay, this sounds terrible.â This is just, âOh God, what are they doing? Oh my, no. Why? Iâm using Mac? What the hell is this?Â No, no, no, Iâm not using â no.â So, okay. And that was Nix. And I was like, âOkay, letâs learn this.âÂ </p>
<p>And I donât really like writing code because code is basically â well, if you write code, it becomes a liability. So, I donât really like writing code and prefer to delete code. So, I looked at the Nix packages in first and was like, the way they do Haskell is fundamentally incompatible with cross-compilation ever because they basically take your cabal file and flatten it out on the machine. They run cabal to Nix, which means you lose all your conditions that are basically important to get Windows to build. Especially for Windows, thereâs often conditions in your cabal files that make the dependency trees completely different. Itâs not like where you just like have Linux or Mac and theyâre mostly the same because everyone pretends Mac is Linux, well, which is not true, but certainly assumed. But for Windows, itâs so different that you canât use the Unix package on Windows. You basically have the Win32 package and whatnot. So, you really need to be careful about not flattening out the cabal file. But the whole cabal to Nix infrastructure in the Nix package system flattens these out. So, itâs like, âOkay, I just canât make this work in any form that even looks remotely sensible. But if we can make this work, if I can just have the cabal files translated in a way that it then can feed to the Nix package, that could work.â And thatâs how it initially started out.Â </p>
<p>So, we basically just flattened them out and then created a construct we could feed into the Nix packages as a component. And then later, weâre like, âOkay, the guy who worked a lot on the Web GHC project who venture came along and was like, âIt would be cool if we ââ I think at least it was him. âIt would be cool if we could do component-level builds because the Nix package infrastructure also builds at the package, level and well, we have components, and well, cabal could technically build at a component level.â So, that also got into haskell.nix component-level builds. And that point, the project started to diverge so much from the way the Nix packages build work. They were like, âOkay, this is basically orthogonal to Nix packages.âÂ </p>
<p>We use Nix packages for system libraries and everything else, but for the Haskell side, we basically use haskell.nix. And that meant we basically try to support a bunch of Nix package revisions and then have these orthogonal to haskell.nix. Technically, all Nix packages revisions should work, but because you want to have some form of caching, we pinned a few in Haskell docs for convenience. And you donât need to use those.Â However, if you want to have better caching, you probably want to use them. And the infrastructure we build for Windows, well, that basically works for Linux as well so you can cross-compile to other Linux architectures.Â </p>
<p>Then Apple came and said, âHey, weâre going to give you ARM MACs eventually. I was like, âOkay, if weâre going to getÂ ARM MACsÂ and we have our really, really bad LLVM backend, thatâs not going to work. Itâs going to be super slow, and people are just going to complain, and whatnot and we really need to improve this. Maybe I can write it backend for a compiler. I mean, I tried this with the bitcode LLVM backends. I had a bit of experience how to write a backend anyway. And this ARM assembly doesnât look too bad. So, letâs try this.â And before that, I already wrote the linker and loader. So,Â letâs take a step back.Â </p>
<p>GHC has an internal linker. Iâm not sure if youâre familiar with that. GHC basically has a static linker where it can load object files and archives into memory, link them together, and then execute that code, which makes it independent of the system linker in case that doesnât work. And on some platforms, there, for example, isnât even one or itâs broken. So, GHC has this facility, it has a bunch of bugs occasionally, which makes for really fun debugging stories.Â </p>
<p><em>JB (0:20:41)</em>: I can imagine.</p>
<p><em>MA (0:20:42)</em>: Having this at least helps you load these. And the way that GHCJS works is by running a client on your target, which for GHCJS is basically Node.js. And we can do the same for iOS or Android by basically running a tiny Haskell application on your mobile phone or on your Android device or whatnot, which then loads object files and executes them for Template Haskell. Maybe we should explain Template Haskell. I donât know. Should we?</p>
<p><em>JB (0:21:13)</em>: Maybe briefly?</p>
<p><em>MPG (0:21:14)</em>: Yeah.</p>
<p><em>MA (0:21:14)</em>: Okay. So, TemplateÂ Haskell,Â a feature which we shouldnât really be having, allows us to run arbitrary IO and process stuff during compilation. And that meansÂ TemplateÂ HaskellÂ also has this feature and is able to load arbitrary code during compilation time and execute those functions, which it even uses. So, if you evaluate your splice, basically take the Haskell function, load it into memory, evaluate and run it and take the result to splice it back in. This splice could also load some other C functions and do basically anything IO. Itâs unrestricted. It canât even call out to Git, which people do, and use this git and embed thing, which has lots of other implications, but thatâs what template Haskell can do. And for that to properly evaluate one option, which was populated â</p>
<p><em>JB (0:22:05)</em>: Sorry, that was me. I pressed a button I didnât want to press. I did not want to interrupt you.</p>
<p><em>MA (0:22:14)</em>:Â There have been two options for this. So, one is what GHCJS does, which is it basically runsÂ TemplateÂ HaskellÂ in an evaluation context for the target, or the other, which is what evil splicer and ZeroTHÂ basically tried, which is youâre runningÂ TemplateÂ HaskellÂ on your build machine, save all the splices, and then hope that these splices are the same ones youâd splice into your target. Well-Typed at some point improved on theÂ ZeroTHÂ and they have a thing that I think automatically dumps your splice and allows them to basically load back in. So, that also works for some cases.Â </p>
<p>But to me, the problem is that the wayÂ TemplateÂ HaskellÂ works is it really assumes that it runs on the target, even though thatâs hard to say because there are no semantics around it at all where it runs. But people assume that it runs on the same platform where theyâre going to run it when people try to see how big are pointers and whatnot and try to poke these during compilation time to compute word sizes. And that can only work if you evaluate on the target. Otherwise, you get the wrong ones if your target and your build machine donât line up.Â </p>
<p><em>JB (0:23:27)</em>: But most of the use ofÂ TemplateÂ HaskellÂ would be fine on that host, would it? At least the ones like weâve encountered?Â </p>
<p><em>MA (0:23:33)</em>: Yes. Most of it. If we just had a pureÂ TemplateÂ Haskell, there would be no problem at all. If you just cut out all IO, including unsafePerformIO, then this would be all okay. If we use Javaâs STG evaluator it has, that would also be fine. But as it is right now, if you want to basically evaluateÂ TemplateÂ Haskell kind ofÂ true to what it seems to be, you still have to evaluate on the target if you can. And that then brings all kinds of other issues, like how do you actually â if yourÂ TemplateÂ HaskellÂ evaluator runs on your mobile phone, how do you actually get files from your build machine? How do you actually execute processes? Should the process be executed on the machine or locally? If youâre loading libraries, most of the time if youâre loading libraries, they really want to run them on the target, and some libraries might just not exist for your build machine. So, that might be like some private library that only exists on your phone or whatnot, and you really are â itâs only available in AArch64. Then you really need to have that failure. But thatâs all fringe case.Â </p>
<p>In Template Haskell, the problem though is that you donât know ahead of time which ones are, right? So, if you want to have a solution thatâs as general as possible, you have to try to go down that route. And thatâs how we basically have linkers and loaders for most of our architectures in GHC. So, GHC can basically load Mach-O files and ELF filesÂ and relocate object files properly in memory so that you can then call functions. And I did work on that for Obsidian Systems years ago, when they basically asked if we could improve the linker.Â </p>
<p>And then later â well, that was forÂ AArch64Â and a bit for ARMv7. And then later, I was like, âOkay, letâs build a code generator for that.â So then, we start building a native code generator over probably six months or so forÂ Mach-OÂ and ELF so that we have Linux and macOSÂ AArch64 targets native code. And then I got one of these Apple development kits to try it out, and that was fun to try out. Initially, it was a bit annoying to bootstrap that all, but thatâs also where I learned to love Nix because, finally, you had like at least some principal development environment where not everything changed all the time.Â </p>
<p>So, if you read some of my earlier blogs where itâs like, okay, this is how you construct a build route for your Raspberry Pi or whatnot by copying stuff from theÂ RaspberryÂ Pi around and rearranging your built environment, thatâs all made so much easier if you use Nix. And thatâs how that native code generator happened. So, I think Iâve spent most of my time working on GHC, not really with GHC.</p>
<p><em>MPG (0:26:04)</em>: So Iâm wondering about the impact of Template Haskell. Say I write a Haskell implementation, call it Nano Haskell, not the Micro Haskell, how far can you get without Template Haskell? Do you just crash right away? How much of the ecosystem are you foregoing or abandoning if you just say, âI donât support Template Haskellâ?Â </p>
<p><em>MA (0:26:29)</em>: How much are you foregoing? I donât have hard numbers. I mean, GHC does not use TemplateÂ HaskellÂ because it itself has a staging problem. The problem with me is more that any realistic program youâre trying to build will somehow end up using Template Haskell somewhere. And thatâs quite annoying. And Iâm like, maybe we could tell people not to useÂ Template Haskell, but is that going anywhere? Weâre going to tell people, âNo, you canât useÂ Template Haskell.â Then people are like, âOkay.â So, theyâre going to try to build their software, and somewhere in their dependency tree, theyâre going to encounter capitalizing, and then nothing works. And theyâre like, âOkay, now Iâm either going to try to figure out how to fix my dependencies or Iâm just going to move on.âÂ </p>
<p>So, from a purely practical perspective, I donât think you can build any of the larger Haskell project without hitting Template Haskell anywhere in your dependency tree. Even though Iâd like to, but yeah, from a practicality perspective, I think itâs pretty much important that you have some form of Template Haskell support.Â </p>
<p><em>JB (0:27:21)</em>: Would it be more plausible to have a host Template Haskell extension that is like Template Haskell, but just runs it all in the host rather than target? Would that make things easier?</p>
<p><em>MA (0:27:30)</em>: Are you going to rope me into plugins now? Because theyâre absolutely not supported in cross-compilation, and thatâs the next frontier.</p>
<p><em>JB (0:27:37)</em>: So, youâre sayingÂ running code on the built host is no easier than running code on the target, and youâre basically in a pain in both cases?</p>
<p><em>MA (0:27:44)</em>: It could be. So, I mean, we have plugins, and they are basically â I think Oleg has some synthetic language extension even based on plugins or something. So, you can do a lot of plugins. The problem is if you have a cross-compiler and you try to use plugins, then the cross-compiler will try to use iServe to run the plugins. And thatâs not going to work because plugins access internal state of the compiler, and iServeÂ does not share this internal state. So, thatâs not working.Â Â </p>
<p><em>JB (0:28:11)</em>: So, at the moment, plugins are even worse for cross-compilation than Template Haskell.</p>
<p><em>MA (0:28:15)</em>: Yes. We have made a lot more progress onÂ Template HaskellÂ than our plugin, though weâre working on plugins as well. Thereâs something called external static plugins, which hopefully can make plugins work, but not all of them yet, and getting them to work as non-trivial. I think there are not many people that actually use them or try to use them.</p>
<p><em>JB (0:28:37)</em>: Yeah, thatâs my impression as well. Plugins are nice for playing around with things, but they donât make their way into common production libraries.</p>
<p><em>MA (0:28:45)</em>: Oh, you havenât seen Pluto, have you?</p>
<p><em>JB (0:28:47)</em>: No, I havenât. Is it full of plugins?</p>
<p><em>MA (0:28:50)</em>: So, the smart contract language for Pluto â for Cardano, itâs called Pluto. And Pluto is basically a GHC plugin that transforms core to turn Haskell core into Plutoâs core.</p>
<p><em>JB (0:29:00)</em>: Okay.</p>
<p><em>MA (0:29:01)</em>: You can cross-compile basically everything unless you start using any of like â unless youâre trying to compile smart contracts during the cross-compilation part.</p>
<p><em>MPG (0:29:10)</em>: And like you said, it feels like plugins are â itâs Template Haskel on steroids, where you are running arbitrary code that can do arbitrary IO as much as you want, but you also want to know all the internal state of GHC at the same time, right?</p>
<p><em>MA (0:29:25)</em>:Â Right. I would say I actually like plugins more because, as the person running the code, I have more control over plugins. Template Haskell is much more opaque to me. I donât know which of my dependencies useÂ Template HaskellÂ automatically, and it can just build something and then run it. TheÂ Template HaskellÂ could just nuke my whole hard drive if it wanted to. It could ex-fill all kinds of data. It could just use my password file and send it somewhere. No one would know. Maybe we should cut this out, but if someone were to take over a popular Haskell package on Hackage and push a slightly malicious piece of code into the Haskell package, for example, letâs say ASIN, to exfiltrate sensitive data, I think youâd have quite a lot of success actually exfiltrating sensitive data. But yeah, Iâm not sure we should publicly make this statement and give people idea.Â </p>
<p><em>JB (0:30:13)</em>: Well, maybeÂ we should because itâs something Iâve been thinking about as well. The amazing amount of trust we open source, especially open source developers, just spread to random people whose package has been installed. And not just Template Haskell; it could be the cabal setup file. It could be some VS Code extension that automatically updates. Youâre giving a vague access to your computer to so many people when you do development that itâs strange we donât hear much more about these problems where some library becomes broke and steal stuff.</p>
<p><em>MA (0:30:50)</em>: I think we only hear this in the Node community occasionally, but â</p>
<p><em>JB (0:30:54)</em>: Because theyâre big enough to â so the bad guys actually think thatâs worth going there.</p>
<p><em>MA (0:30:59)</em>:Â I guess. Thatâs why you should basically run everything you do in sandbox environments. And even those might be escape, but itâs always some form of additional security layer.Â </p>
<p><em>JB (0:31:10)</em>: Yeah. But the list of things you should is always longer than the list of things you do, which â</p>
<p><em>MA (0:31:14)</em>:Â Yes, of course. Right. My mom called me the other day and asked me, âHey, I got a WhatsApp message and someone said, âYou changed your number and this is your new.ââ Iâm like, âYeah, no, forget about this.â And then I was like, âOkay, and now weâre going to do another example.â Iâm like, âWhatâs possible today?â And I took a sample of my sisterâs voice and ran this through a voice cloner, and then basically sent them a message like, âBe very prepared. This is what happens. Someone could be coming with this voice and ask for money. Never send anyone money. Always ask for a third person to confirm what you just heard. Never trust anyone. Not even if you see a video. Those are easily fakeable as well as this point.â We are in a position where we know about this and most of our families donât. So, itâs on us to educate them around these things.Â </p>
<p><em>JB (0:32:03)</em>:Â Yeah. But as long as you just cabal-install random packages or in node-install random packages, itâs not like we can if we have the more high ground here.Â </p>
<p><em>MA (0:32:11)</em>: Well, yeah. Depending how you do this, yes.Â </p>
<p><em>JB (0:32:14)</em>: Maybe IÂ shouldnât publicly say that. I know that I should have more security.</p>
<p><em>MA (0:32:18)</em>: Right.</p>
<p><em>JB (0:32:19)</em>: I have perfect security. No point attacking packages I use. Itâs totally locked down. Iâm using cubes in cubes in cubes. Itâs totally safe.</p>
<p><em>MA (0:32:27)</em>: Thatâs why you build everything in Nix, arenât you? Isolating your build environment, try to make sure it canât reach anywhere outside?</p>
<p><em>JB (0:32:33)</em>: Yeah, no.</p>
<p><em>MPG (0:32:35)</em>: I have a computer in my basement.</p>
<p><em>MA (0:32:38)</em>: For Haskell development.Â </p>
<p><em>MPG (0:32:39)</em>: I go down there, I cabal â yeah. I cabal-install a package there and then I copy the files. Yeah.</p>
<p><em>JB (0:32:46)</em>: And always wear protective gear with like a hat and antiseptic hat gloves before I touch new Haskell code.</p>
<p><em>MPG (0:32:53)</em>:Â Exactly.Â </p>
<p><em>MA (0:32:53)</em>: See, I have my alcoholÂ pads here.</p>
<p><em>JB (0:32:57)</em>: Oh, thatâs very good. You can disinfect everything you touch.Â </p>
<p><em>MA (0:33:02)</em>: No, wait. But you mentioned Setup.hs,Â and Setup.hsÂ is one that, especially if youâre trying to cross-compile with cabal, is really annoying because cabal has not really any idea how to deal with it properly. It can only compile it for your build host and then run it. For GHCJS, weâre trying to see if we should basically compile it to JavaScript and then evaluate there. That makes a better solution. I donât know. Haskell.nix basically builds them on your build host, and then it just evaluates them.Â Haskell.nixÂ has a bit easier time because we donât really use cabal-install. We use cabal-install to build a plan and then runÂ Setup.hsÂ to actually do any of the building. So, in that, we have a cleaner separation there than cabal.Â </p>
<p>ButÂ Setup.hsÂ in general is, to me, a bit less annoying than Template Haskell becauseÂ Setup.hs, I can declaratively know. Template Haskell,Â I canât.</p>
<p><em>JB (0:33:54)</em>:Â Thatâs true.Â </p>
<p><em>MA (0:33:55)</em>: Template HaskellÂ just happens. Setup.hs,Â I can see, okay, itâs custom or set up or make or configure or whatnot, in the cabal file at least declared if youâre using cabal. If youâre going to use for, I think,Â BazelÂ rules or whatnot, then I think thatâs also all out of the window. But yes, at least that, we have a description for.</p>
<p><em>JB (0:34:15)</em>:Â Okay. So, we can summarize that Template Haskell adds a lot of headaches for cross-compilation.Â </p>
<p><em>MA (0:34:20)</em>: Yes.Â </p>
<p><em>JB (0:34:21)</em>: But itâs a very gentle transition to another big topic. Template Haskell is also causing headaches for another big topic that you strongly care about and has been very vocal recently. And we should definitely make sure we have enough time to get into that. And that is the whole stability discussion.Â </p>
<p><em>MA (0:34:34)</em>: Yes.Â </p>
<p><em>JB (0:34:35)</em>: Maybe for a little bit of context, at least from my point of view, GHC has been a language that has always valued evolution and experimenting things. And that came at the cost, or at least appear to came at the cost, of, well, you upgrade GHC and your code no longer works. And some people surprisingly donât like that and have plans to how we could do that better. And more, itâs one of the more very vocal advocates for stability, which is definitely a good thing. And I think youâre actually working on a concrete proposal at the moment.</p>
<p><em>MA (0:35:05)</em>: I try to. I then had a bit of a medical problem that threw me off. And I think Simon basically went and took the button up, I guess, because I didnât. And yeah, well, my fault. Simon is working on the stability guidelines around doing things. And thatâs, I think, a very good step in the right direction.</p>
<p><em>JB (0:35:24)</em>: Can you summarize the plan that is in the discussion here?</p>
<p><em>MA (0:35:29)</em>: So,Â just on a high level, itâs like, letâs be a bit more mindful about what breakage means, what breakage causes. And if we can have backwards compatibility, letâs try to have backwards compatibility before we basically just break stuff randomly. So, I think itâs mostly just being a lot more mindful around this. And this comes with â I think Simon came with three general rules, how to do this. I would have to look them up right now, but the general consensus is that if you donât really need to break it, donât break it. If you need to break it, have at least some form of compatibility or migration path, and only break stuff if you really canât do otherwise. And I think that goes in the right direction. I mean, it still excludes Template Haskell because, well, you donât get really any stability guarantees if you use Template Haskell, which brings us back to the previous point where we said, âDo we actually need Template Haskell?âÂ And sadly, I think we do.Â </p>
<p>So, the thing withÂ Template Haskell isÂ Template HaskellÂ exposes internals of the compiler. And the question of it to me is if it really should be doing that at all, or if it should basically just give you a high-level combinator library and then tries to abstract the internals from you. And maybe most use cases of Template Haskell would even be working with just high-level combinators and donât need to have full access to the internal data structures of GHC. And that would make it a bit easier.</p>
<p><em>JB (0:36:49)</em>: I guess a part of that problem is also that GHG, the library that exists is basically just, well, letâs open up all the modules that make up GHC the compiler, and you can use whatever you want, but itâs in no way designed and structured and curated API, and so it changes totally between releases.</p>
<p><em>MA (0:37:07)</em>:Â Yes. So, we donât have an API to the compiler. We basically just have the compiler. I mean, the library thatâs called GHC is basically the compiler folder in the GHC source directory.</p>
<p><em>JB (0:37:19)</em>: Yes.</p>
<p><em>MA (0:37:20)</em>:Â So, it is the compiler. For stability, why do I care in the first place? The problem is, if I, as a company, invest in Haskell and I want to build software in Haskell, at some point, I need to upgrade to a new compiler release because the ecosystem just moves on. Or I decide to basically rewrite my whole new ecosystem at home and just donât play with anyone else. Iâm not sure if thatâs a workable solution. I think that might be a workable solution for banks. Jane Street does a bit of that on the OCaml side, where they basically just reimplemented all of their standard library in their own one. But I think itâs counterproductive doing this unless you have as they did in OCaml, where they have basically got the whole community buying. ButÂ itâs counterproductive. Every company ends up building their own libraries in-house just to insulate them from other peopleâs dependencies. Then why do we do this in the first place? I mean, sure, if youâre in high insurance context where even using external library might be super annoying because it needs to pass legal and whatnot, internal reviews, and all these kind of things, basically insulate against the things you said you might be running into by just running cover update, then sure. But ultimately, I think we should all work towards collectively working on software, not everyone doing their own stuff. Thatâs why we try to basically use other peopleâs software and trust that they know what theyâre doing.Â </p>
<p>And now, you have a piece of software you wrote, and eventually, you need to upgrade the compiler because either you want a new dependency, and that brings in yet another dependency, which doesnât build with the old compiler anymore, or whatever happens. And that forces a compiler upgrade. Or you think, well, I want to target a new system. For example, I want to use the native code generator for my Macs because theyâre significantly faster than the LLVM backend, and you need a new compiler, which means likeÂ 92 Plus. Now you need to upgrade, and you take your existing code base, and you could see, oh, nothing really compiles out of the box anymore. Basically, every package I have somehow doesnât compile anymore.Â </p>
<p>At that point, what do you do? You either say, âOkay, Iâm going to invest and basically upgrade all the packages, even though I donât fully understand why I need to because the com code used to build, so what the hell is going on?â And I think if this happens often enough, you might just say like, âWhy are we using Haskell in the first place? Why are we paying this continuous tax on upgrading packages and spending time on that?â Because thatâs similar to what I said initially. We want to solve problems with software. We donât really want to solve software with software because of software.</p>
<p><em>JB (0:39:53)</em>: Right.</p>
<p><em>MA (0:39:54)</em>: So, maybe then the option becomes, âOh, thereâs a language that does not break so often. Maybe we should be using that one.â That is basically where my point is. And I donât want to employ someone full-term just to make sure our code base keeps compiling with the next GHC.Â </p>
<p><em>JB (0:40:09)</em>: So, maybe the question now is, what are the cases where compilation breaks with the next GHC? Which of these could be avoided without any pain to anybody else? Which of these would take effort thatâs worthwhile to invest so that breakage doesnât happen? And which of these are really unavoidable if you just donât want to freeze the language in time, and what is the trade-off there?</p>
<p><em>MA (0:40:32)</em>:Â Yeah, I think that thatâs a very good question. I think Iâm not sure if anyone really has a good answer to that. I know Tom is currently collecting, I think, breakages from 8.6 to 9.6, or was it from 9.6 to 9.8? I donât remember. But yeah, at least I think Tom is currently keeping count. Iâm not saying that all the issues we ran into were only compilation-related â only language-related. But what happens is you upgraded library, and now that library you upgraded needs to be integrated to other libraries because you have this forward-rolling thing where your current stack, at least if you have multiple libraries and not monorepo, depends on existing libraries. And now you obviously can start doing all of your existing libraries at their current snapshot, upgrade them, and upgrade master as well because thatâs the current head version. But if you only do master, then you have a new release, then that needs to be integrated in your current versions so you can basically have this ripple down. And that just ends up being a lot of work.Â </p>
<p>And itâs small things where language extensions somehow change or imports change, or something else changes. So, Iâm just like, if we can reduce any unnecessary breakage, maybe itâs getting easier. So, Iâm pushing really hard for unnecessary breakage. And if weâre doing breakage, letâs at least try to make sure that the person who encounters that breakage knows exactly what to do. Nothing is more frustrating if something breaks and youâre like, âOkay, what do I do? Do I need to rewrite it? How do I fix this?â And sometimes, I mean, we do try to write this down in the user guide to have migration notes, like this change from GHC x to GHC y, and this is you â well, sometimes it says that this is how youâre supposed to fix it. But you also have to mention there, thereâs someone who might not be that familiar with the code base but is tasked with doing the upgrade for other teams because other teams are working on their features theyâre supposed to implement, and thereâs someone whoâs just trying to also get the compatibility with the new compiler working.Â </p>
<p>And one really big issue I have with the compiler not accepting existing language is that, how do we do proper quality control? If I canât compile the code with two compilers, I canât really do regression check testing properly.</p>
<p><em>JB (0:42:40)</em>: Thatâs an interesting point. Yes.Â </p>
<p><em>MA (0:42:42)</em>: My code compiled with compiler X, and I have performance metrics for that. I have behavior metrics for that. Now Iâm taking a new compiler, nothing compiles anymore, so I have to make changes to my code. But now these changes end up potentially influencing performance and behavior. So then, I may need to make changes that are hopefully compatible with both compilers, but that mostly is not the case. So, you have conditionalÂ ifdefsÂ in the com code, and that means youâre basically comparing oranges to apples, kind of. Itâs not the same quality control anymore. And yeah, thatâs why I think at least from one to the next compiler, at least letâs try to make sure we can still combine the same code. Thatâs what Iâm pushing for.Â </p>
<p><em>JB (0:43:22)</em>: WhatÂ I had found as an interesting takeaway from the whole discussion is the observation that in the cases where you do want to make a break at some point eventually because the old code is â you just want to keep it going. Initially, my thought was, well, how useful is deprecation even? Because people have to make the change anyway, and many people will just ignore the warning until it really breaks. And so, for them, they donât gain much from deprecation. And also,Â Simon MarlowÂ reported from his experience at Facebook, I think, that they more or less donât do that and they just wait for the break to happen. But then I realized itâs not about less work; itâs about giving people a window of time where they can choose when to make that work. And more importantly, they donât have to do it in dependency order anymore.</p>
<p><em>MA (0:44:07)</em>: Yes, you can do it ahead of time.Â </p>
<p><em>JB (0:44:09)</em>: They can paralyze it in a way. And they can build the whole thing and then they can fix one warning after time and still check whether that works, which is of course a much more pleasant experience than going through your code in dependency order and fix all the errors. As much maybe as vs Haskell developers like this experience with refactoring, where we really love the compiler telling us this breaks, and now this breaks and I can just fix it all the way. But the refactoring is something you do intentionally and fixing, break it from upgrading GHC because you had to upgrade GHC for some other reason. Thatâs painful. And for me, that was an interesting insight that itâs not about less work; itâs about better timing for when you do the work for the poor users who have to do it.Â </p>
<p><em>MA (0:44:52)</em>: Yes.Â </p>
<p><em>JB (0:44:53)</em>: I opened up the proposal. Maybe itâs worth to summarize it quickly because Iâm sure also that our listeners will be curious what weâre discussing there. So, the stability proposal, more itâs initiated, and Simon then fleshed out a little bit, that the basic rule and promise is that a stable Haskell packageâand weâll get into what a stable Haskell package isâthat works with one version of GHC should work at a subsequent version of GHC, assuming all the dependencies already work. And so, if you depend on something thatâs not stable, then of course, that can break. But then if all the dependencies are stable, then there should be a guarantee that we really â well, maybe âguaranteeâ is a strong word, but a strong promise that we try really, really hard so that in the future, if something works with one version of GHC and you stick to certain rules, then it will work in the next version.Â </p>
<p>And the rules also may be worth rehashing. For example, obviously, you certainly depend on libraries that follow this kind of rule and not depend on the GHC internals, for example, and it should follow the PVP and things. And for example, you should not enable that every warning is an error because we will not be able to guarantee that we wonât add new warnings in a new version of GHC, which would turn into errors if you choose to do so. So, thereâs some restrictions in what the developer should do in order to get the benefit of the improved stability regime in GHC. Also, you shouldnât just be using any language extension that exists there, but there will probably be a list of language extensions that we consider stable enough that we really try too hard, try hard to give you this promise, and others where, well, if you use that extension, then youâre opting into something thatâs unstable.</p>
<p>And then there is exceptions. We may break this promise, but only for a good reason with a very vague rule. But at least now, we have to justify that we have a good reason, and we also promise or try to look into the kind of impact the change has. Like how many packages will be broken?Â </p>
<p>And then thereâs this little third rule where if you do have a compelling reason to break, then at least weâll try really, really hard to give you a deprecation cycle for the reason we just discussed so that you can compare different compiler versions against the other, that you can upgrade working code rather than having to operate on broken code. And this sounds all very reasonable and written like this, and it will be very exciting to see if you can actually stick to it and practice because, just, I donât know, last week, there was some extension discussion whether thereâs, oh, but this little break, itâs probably going to be very unlikely, and very few packages have ever do this kind of thing. So, we can just fix it right away. And Iâm thinking, intuitively, yes, this is how I learned how Haskell development works, but then I pointed out, this breaks the rules that we just set out to follow ourselves, and weâll see how well it goes.</p>
<p><em>MA (0:47:50)</em>:Â Yes. You said weâre refactoring, but thatâs usually contained to one package youâre looking at. Itâs not that you end up having to refactor other peopleâs code on the spot because youâre trying to make it work.Â </p>
<p><em>JB (0:48:03)</em>: Yeah.</p>
<p><em>MA (0:48:04)</em>: And the other is, if we have deprecation warnings, it also means we give people a heads up whatâs going to come and change. And that might mean that you actually get people to discuss that a certain feature that people think is sensible and is going to change in GHC may actually draw a lot of feedback from the community telling you that there are actually cases where we donât really want this because currently, if you want to be in on whatâs going to change in GHC, youâre mostly to be part of the steering committee. If youâre not part of the steering committee, how do you actually see whatâs going on?</p>
<p><em>JB (0:48:34)</em>:Â I guess you follow me on Twitter, and I post the proposal that I accepted.</p>
<p><em>MA (0:48:39)</em>: Yeah. And thatâs a bit after the fact.Â </p>
<p><em>JB (0:48:42)</em>: Well, with the GHC proposals, acceptance is still before implementation. So, unlike, for example, the base library, where the committee decides basically on ready-to-merge pull requests. In our case, thereâs still plenty of time between acceptance and implementation. And if somebody finds something wrong with an accepted proposal, please, by all means, reach out. Itâs not too late.</p>
<p><em>MA (0:49:04)</em>: Right. But how do you actually â as a working programmer, how do you stumble upon the proposals?Â You donât. I mean, you do once they end up in your compile and youâre, âOh.â</p>
<p><em>JB (0:49:15)</em>:Â Yeah, then itâs too late or almost too late.</p>
<p><em>MA (0:49:17)</em>:Â The compiler is effectively the interface to the working program. And I mean, from the discussion where I kicked â where I basically complained about stability on discourse, and eventually people said, âHey, you should join the steering committee.â I was like, âIâm not sure. I donât really care that much about language research. Why should I be on the steering committee?â Theyâre like, âYeah, maybe you should.â So, now Iâm on the steering committee, and most of the times, Iâm just asking, is this going to break existing code? And if so, Iâm going to be against it.Â </p>
<p><em>JB (0:49:46)</em>: Well, itâs a good thing to have on the committee if that is a few that was underrepresented.</p>
<p><em>MA (0:49:51)</em>: Right. Iâm just saying the setup we have is that I think people who care about this do not think that the steering committee would be the right place for them, because if you donât really care about language development and whatnot, and youâre like, âI really only care about Haskell getting from a purely system-compatible engineering standpoint better,â then what am I doing on the steering committee? Most of the stuff youâre doing is never going to hit the steering committee. So, Iâm going to fix the linker for some platform. Thatâs not going to hit the steering committee.</p>
<p><em>JB (0:50:20)</em>: Luckily.</p>
<p><em>MA (0:50:21)</em>: And the steering committee is, I think, mostly comprised of people who are actually interested in pushing GHC as a language reactor forward. Itâs a very one-sided view on topics. I mean, you can disagree, but â</p>
<p><em>JB (0:50:35)</em>: I think we have a fraction of people on the committee who are not just pushing, but also trying to steer in the sense that, letâs just not push in all directions at the same time. But Iâm always sad that Yavo left because he was always a good voice that was asking questions about like, do we want that to be Haskell? And maybe we definitely need more people who take that stance?</p>
<p><em>MA (0:50:55)</em>: Well, thatâs still language-wise, right?</p>
<p><em>JB (0:50:58)</em>: Sure, sure. Itâ stillÂ language-wise, yeah. But on the other hand, itâs also good that you donât need to go through a committee if you want to fix the build, the linker, or something.</p>
<p><em>MA (0:51:06)</em>: No. Thatâs why I just think thereâs like this anti-selection for people who are interested in the steering committees and all of these committees in general, and then these who just try to unbreak stuff. Letâs just fix the bug and make stuff work better. I mean, we see this on the CLC as well where â</p>
<p><em>JB (0:51:25)</em>: The Core Library Committee?</p>
<p><em>MA (0:51:27)</em>: Yeah, where people basically try to like, okay, can we maybe try not to break stuff? And I think there are quite a few who actually try to work towards this, but itâs not always easy to predict breakage ahead of time. And yes, you can compile the CLC stackage and see if any of that breaks. But for the steering committee, where thereâs not even an implementation, thatâs even harder, I think.Â </p>
<p><em>MPG (0:51:45)</em>: Because the thing with deprecation is there are two big advantages. So, first of all, itâs like a custom error message. You can say, âHey, youâre doing this, and you should do this next.â So, you can put the user update guide directly into the compiler message, which is great. And second of all is that a deprecation warning, particularly, itâs not breaking code. So, if I break something, I canât run the tests because it doesnât compile anymore. But if itâs deprecated, I can fix part of it, run the tests, fix part of it, run the tests, right?</p>
<p><em>MA (0:52:20)</em>: Yes.</p>
<p><em>MPG (0:52:20)</em>: So, I think itâs very important to be able to â as you said before, you want to be able to compare versions and check whether it works and how it performs incrementally, and not just, âHereâs a new version, hereâs a huge patch that I put on top.â And now it all works, but which part made it slower, or which part made it better?</p>
<p><em>JB (0:52:41)</em>: What still bothers me about this view, or maybe âbothersâ is a strong word, but it requires discipline in the sense that people actually need to look out for these deprecation warnings and fix them before they â well, before they acted on, and now things break. And I know from my own experience, and maybe this is better, this is different if youâre in a corporate environment and you put up rules and you put up CI for that, but for my own projects, I see a deprecation warning scroll by in the build. And I think, okay, do we want to fix this now? Maybe Iâll just fix it when I really have to. And then some of the deprecation warnings Iâve been seeing scrolling by for more than a decade. A byteÂ StringBuilderÂ get lazy and or whatever itâs called. Iâm looking at you. But then, of course, itâs my choice. I know that there is a certain rule I can follow, namely, take care of deprecation warnings between two releases and you will have a much better time. And if I have a worse time, because I donât do that, at least I donât get to complain. I could do it differently.</p>
<p><em>MPG (0:53:34)</em>: But I mean, at least I didnât get a good error message. You donât just get, âThis function doesnât exist or could not unify true or false.â Why? Why? And then you can compile with the old version. Itâs like, âOh, okay, I need to change the constraints here.â</p>
<p><em>MA (0:53:48)</em>: Yeah. So, I hope this is going to move us in the right direction. I mean, Iâm not sure anyone of us really knows if itâs going to make that much of an impact. Without actually having and trying, we wonât be able to see it. And I have this other proposal for having this experimental flag because also we donât really know what other experimental extensions are today. No one really knows. There are some that are marked in the user guide as experimental. Then there are extensions where people think theyâre experimental or they consider experimental. I mean, Joachim knows this very well from that whole discussion around GHC 2024 and whatnot, which extensions are actually next,Â orÂ shouldnât be warned? And thereâs a very, very big gamut of people thinking different things about stability of extensions. And I had a call with â I know at some point where he said he does not believe that this experimental flag is actually going to help; itâs just going to add more noise and whatnot. During that call, he figured that GHC today even helpfully suggests to enable linear types if you put in the syntax.</p>
<p>And the question of GHC should suggest you to do this today. And my thinking is we need to have GHC be able to tell you if stuff is experimental. And for that, GHC needs to have this binary flag. This is experimental or not. And then we need to add the metadata to extensions, so GHC can actually knows this, because again, GHC is the interface for the programmer. Itâs not the user guide. If I ask people at the work, who reads the user guide? I guess 5% read them, especially for each version, to figure out which is now new or whatnot. And thatâs why I want this experimental flag.</p>
<p>And we start out with like, basically nothing is experimental, but then we can start to at least first have another proposal that says, okay, letâs move the extensions that are in the user guide that say that they are experimental behind this flag because, well, we seem to agree theyâre experimental. And then we can start adding more. We say this is experimental. And the thing that experimental should give you is that if itâs experimental, the author of that extension can, at any point, without warning, break that thing as he wants. Itâs basically technology preview. You can try it. If it breaks, youâre out. But if itâs not experimental anymore, then it means people start relying on it and should be able to rely on it. And then you canât just break it from now to the next thing without warning. So, there needs to be some form of deprecation. At least thatâs what I hope this would be.Â </p>
<p>And now the problem is, if we put Template Haskell into experimental, then everything ends up being experimental. And thatâs a big question, how to do this properly, because Iâd like to enforce no experimental in CI for us because that means that we get the guarantee that stuff should work with the next compiler. Weâre still very, very far out from that, but at least that would give us the baseline to do it. And I had people implement this in GHC. So, for the proposal, there is an implementation as well, which gives us the experimental flag. And it basically uses interface files to attain dependencies. So, you basically get this tainting up all the way to where you are and can see if anything in your dependencies is experimental because thatâs the core part. If anything of your dependencies is experimental, then well, the dependency can break, so everything can break.</p>
<p><em>JB (0:56:43)</em>: Yeah. I guess there are two variants that we could aim for. One is where you say, okay, a stable package, which I guess is just the dual of not using experimental under the stability proposal, only gets to depend on stable packages. And the other one is, it gets to depend on whatever it wants, but the guarantee is that whoever controls the upstream package fixes that, your package would still work. And I think they both have justification. Eventually, thereâs going to be some internals inside base and libraries that base depend on. And it may be okay to use very unstable features if you upgrade quickly, like evolve.</p>
<p><em>MA (0:57:22)</em>: Thereâs this thing which is like packages that come with GHC. Theyâre bound to your GHC version.</p>
<p><em>JB (0:57:28)</em>:Â So you would give them special status but not others packages.Â </p>
<p><em>MA (0:57:30)</em>: Yes. Itâs hard. I mean, as long as we canât reinstall base, base is basically GHC. If you upgrade GHC, you get a new base. So, as long as base depends on any form of GHC internals, but provides a stable API to the outside world, then for any consumer, itâs invisible. But if any other package in between starts claiming to be stable, but depending on experimental stuff, then well, as soon as the compiler upgrades, anything in the chain up to that package can break. And if I depend on that package, I also break.</p>
<p><em>JB (0:57:59)</em>: Right. But it would just mean that from your point of view, letâs sayÂ byte stringÂ as example of a relatively low-level package that is not â well, it comes with GHC. Itâs probably a bad example.Â </p>
<p><em>MA (0:58:08)</em>: I would say we should work hard to make the packages we can reinstall much, much larger. And there are only a few we really canât. So, basically, the whole closure up to Template Haskell, you canât reinstall. It doesnât work because you need some form of stable identifiers across it.Â </p>
<p><em>JB (0:58:23)</em>: No, but I think what I wanted to get at is that from the point of view of a practical developer, one could say, âWell, the point when you want to start upgrading GHC is when there was a GHC release.â Or you could say, âWell, for you, the point to start upgrading is when GHC plus a few libraries have upgraded.â And then you get the stability guarantees that your code does not break, which is less, but it would allow packages like â well, to use Template Haskell internally. But you donât look convinced that this is not achieving what you want to achieve.</p>
<p><em>MA (0:58:55)</em>: I think we should coordinate with the authors of these packages around this aggressively if we want to do this. But I know from Ben and others that they even had issues with the boot libraries getting those into shape for releases. So, Iâm not sure thatâs happened. I mean, what I do know is that any GHC before, like a 0.4 release, I donât really need to touch. I mean, Iâm surprised Iâm actually using 9.6.3 already because that hasnât hit 4 yet. But usually, the four minor release was usually the one that started being usable. And before that, there were a bunch. But that is also related to the stability.Â </p>
<p>So, GHC cuts a release, gives you release candidates or alphas, and whatnot. And who then starts and actually compiles the software with them?Â If you have anything that has a non-trivial amount of dependencies, you probably donât because you know most of the things wonât be building anyway. So, youâre like, âOkay, someone else got to trade.â So, the GHC developers donât really get feedback during alphas and release candidates about their versions because, for most people, itâs just not usable at that point. So, people start waiting for release, and then they say, âOh, it still doesnât build.â So, they wait for the next point release and whatnot. But that means that basically, the minor 1, 2, 3, whatever, are better end release candidates in reality from an ecosystemâs perspective.Â </p>
<p><em>JB (1:00:16)</em>: Yeah. It seems to be a consequence of this very bizarre development in Haskell, where all the ecosystem doesnât have a clear, defined edge. Itâs like spread out.</p>
<p><em>MA (1:00:25)</em>: One thing for maintainers is also like, âOh, a new GHC release comes?â I think for quite a few, itâs actually a bit fearful because it means, âOh God, whatâs going to break now? How many weekends do I need to spend to fix up all these, figure out which upper bones I need to bum? Which things still work? Are there new failures and whatnot?â Having this experimental flag needs to be accompanied by a massive CI setup that enforces that. Otherwise, itâs not going to have any value. So, I would be planning to try to set up the infrastructure as well. Having had quite a few of built machines and a bit of built experience. Now thatâs what I probably would try to do. But yeah, where this will take us, I donât know.Â </p>
<p>And ultimately, we canât have single people do this. If I just keep going to do this, itâs not going to be sustainable. Itâs the same reason why I want to talk about theÂ RISC-VÂ backend a bit because Ben is doing a really good job there. Well, Iâm interested inÂ RISC-VÂ as well. I have a bunch of the single-board computers with theÂ RISC-VÂ lying on my desk. And I donât want to be the person implementing that backend. There is no point in me implementing new code gen backends one after the other. We need to spread this knowledge. There needs to be more people knowing how to do this.Â </p>
<p>So. BenÂ came and said, âHey, I want to do this.â I was like, âPlease, Iâm happy to mentor and help and whatnot.â I really want people to learn this, and I think itâs great to learn, and please do this. So,Â we need to really focus on spreading knowledge and mentoring people to make this work and especially spread it across multiple people.Â </p>
<p>I also work on a website calledÂ mobilehaskell.org, which is currently just one of these Docusaurus standard pages, but should probably be much more flashed out in a week or two. I try to write down all of these cross-compilation things, how to build static stuff, how to build iOS stuff, how to build Android stuff. Itâll certainly use Nix because, well, Cabal is just nowhere near where we need it to be for any of this. But we need to write this down way more what we can do. I donât think many people know that we can build iOS applications today in there. Even people who â I mean, if you know this SimpleX ChatÂ thing, which is on iOS and Android, that thing is completely built on Haskell, even as like desktop apps and whatnot. You can do it today.</p>
<p><em>JB (1:02:33)</em>: So, Iâd like to add one thought to the stability discussion. High checking a bit of this podcast with my own messages, but maybe thatâs okay. So, for me, one of the appeals of Haskell, of course, is that it is a language that evolves and tries out new things and inspires other languages. And when I hear somebody say that Haskell needs to be more stable and break less often than enough, I feel like this will change how Haskell is. But I think thatâs actually no longer the case, or at least, I donât know. Iâll have that vary. And I think language extensions can help a lot â or sorry, languageÂ editionsÂ can help a lot there in the sense that we can decouple the evolution of the language from GHC versions and couple them with language editions. So, you can upgrade your GHC, and youâll stay on GHC 2021 language extension on your code if you want. And if you want to have the new fancy, totally different Haskell syntax and maybe big changes even possible, there could be huge changes theoretically. But theyâre not going to be forced on you. You just opt in when you â when and if you choose to change the language edition you want to base it on. And therefore, itâs no longer breaking change. So, it seems that language evolution and breaking changes are not that much of a conflict that you might initially think. And I think we should â thereâs a, first of all, message to spread so that both camps, so to say, are less worried about what the other camp wants to do.</p>
<p><em>MA (1:03:58)</em>: I do agree that language extensions is a good way forward because it gives people an idea where weâre breaking changes. I think the issue we might run into is if people want to change existing extensions, because now youâre starting to have this matrix of language extensions. Do they behave differently depending on your language edition? And I donât think we want this. I think youâd rather want to have like, I donât know, the new types too for a different version at some point.</p>
<p><em>JB (1:04:28)</em>: Plausible. Yeah. I think this is an implementation detail. But the overall idea that stability and evolution can both be provided is something that makes me actually optimistic.Â </p>
<p><em>MA (1:04:39)</em>: Yes.Â </p>
<p><em>JB (1:04:39)</em>: And Iâm sure weâll find ways.</p>
<p><em>MA (1:04:42)</em>: I hope I never made it look like that was impossible. That was never my intention. My intention was that I think we can have a stable subset and keep that across languages. We just donât need to break it with every version and then lead to maintainer burnout and whatnot. And people just like, âOh, I want to test this.â Because really for GHC development, I want people to early test. So, if I know I can take 9.8 and run our whole code base against 9.8 and provide bug reports and regression reports to GHC, Iâd be happy to do this. But I think for most companies, thatâs just not a realistic position to take because if you put in a new compiler, nothing works anymore. So, yeah, a large part is this quality assurance part, which maybe I did not stress enough. And then the other is that, obviously, I donât want to spend so much money on migrating all the time.</p>
<p><em>JB (1:05:33)</em>: Cool. That was a very interesting discussion. Thanks for that. What are the final thoughts before we wrap up? Any last messages?Â </p>
<p><em>MA (1:05:42)</em>: Well, I hope to be able to do Haskell quite a bit more. Weâll see what the next year brings.</p>
<p><em>MPG (1:05:47)</em>: All right. Thanks for coming on the show.Â </p>
<p><em>MA (1:05:49)</em>: My pleasure.Â </p>
<p><em>MPG (1:05:50)</em>: Iâm excited to see how everything turns out with stability.Â </p>
<p><em>MA (1:05:53)</em>: I think we all are.</p>
<p><em>Narrator (1:05:56)</em>: The Haskell Interlude Podcast is a project of the Haskell Foundation, and it is made possible by the generous support of our sponsors, especially the Monad-level sponsors: GitHub, Input Output, Juspay, and Meta.</p>
    </div>
  </div>
  
</div>

    </div>

    <div class="max-w-screen-xl mx-auto text-center sm:px-12 md:px-12 lg:px-16 mt-32">
  <div class="font-bold">SPONSORS</div>

  <div class="mt-16">
    <div class="font-bold">Gold</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://iohk.io/" target="_blank" class="block w-48 m-4"><img alt="IOHK" src="../../assets/images/sponsors/iohk/iohk-683.png" srcset="../../assets/images/sponsors/iohk/iohk-200.png 200w, /assets/images/sponsors/iohk/iohk-400.png 400w, /assets/images/sponsors/iohk/iohk-683.png 683w"></a>
    
    <a href="https://juspay.in" target="_blank" class="block w-48 m-4"><img alt="Juspay" src="../../assets/images/sponsors/juspay/juspay_logo.png"></a>
    
    <a href="https://mercury.com/" target="_blank" class="block w-48 m-4"><img alt="Mercury" src="../../assets/images/sponsors/mercury/mercury.png"></a>
    
  </div>

  <div class="mt-16">
    <div class="font-bold">Silver</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://www.sc.com/en/" target="_blank" class="block w-36 m-4"><img alt="Standard Chartered" src="../../assets/images/sponsors/standard-chartered/scb-logo.png"></a>
    
    <a href="https://tweag.io/" target="_blank" class="block w-36 m-4"><img alt="Tweag" src="../../assets/images/sponsors/tweag/tweag-683.png" srcset="../../assets/images/sponsors/tweag/tweag-200.png 200w, /assets/images/sponsors/tweag/tweag-400.png 400w, /assets/images/sponsors/tweag/tweag-683.png 683w"></a>
    
    <a href="https://well-typed.com/" target="_blank" class="block w-36 m-4"><img alt="Well-Typed" src="../../assets/images/sponsors/well-typed/well-typed-683.png" srcset="../../assets/images/sponsors/well-typed/well-typed-200.png 200w, /assets/images/sponsors/well-typed/well-typed-400.png 400w, /assets/images/sponsors/well-typed/well-typed-683.png 683w"></a>
    
  </div>

  <div class="mt-16">
    <div class="font-bold">Bronze</div>
  </div>
  <div class="flex flex-wrap items-center justify-center">
    
    <a href="https://www.channable.com/" target="_blank" class="block w-24 m-4"><img alt="Channable" src="../../assets/images/sponsors/channable/channable-683.png" srcset="../../assets/images/sponsors/channable/channable-200.png 200w, /assets/images/sponsors/channable/channable-400.png 400w, /assets/images/sponsors/channable/channable-683.png 683w"></a>
    
    <a href="https://www.digitalocean.com" target="_blank" class="block w-24 m-4"><img alt="DigitalOcean" src="../../assets/images/sponsors/digital-ocean/DO-logo-683.png" srcset="../../assets/images/sponsors/digital-ocean/DO-200.png 200w, /assets/images/sponsors/digital-ocean/DO-400.png 400w, /assets/images/sponsors/digital-ocean/DO-logo-683.png 683w"></a>
    
    <a href="https://opensource.google/" target="_blank" class="block w-24 m-4"><img alt="Google" src="../../assets/images/sponsors/google/google-683.png" srcset="../../assets/images/sponsors/google/google-200.png 200w, /assets/images/sponsors/google/google-400.png 400w, /assets/images/sponsors/google/google-683.png 683w"></a>
    
    <a href="https://qbaylogic.com/" target="_blank" class="block w-24 m-4"><img alt="QBayLogic" src="../../assets/images/sponsors/qbaylogic/qbaylogic-683.png" srcset="../../assets/images/sponsors/qbaylogic/qbaylogic-200.png 200w, /assets/images/sponsors/qbaylogic/qbaylogic-400.png 400w, /assets/images/sponsors/qbaylogic/qbaylogic-683.png 683w"></a>
    
    <a href="https://tripshot.com/" target="_blank" class="block w-24 m-4"><img alt="TripShot" src="../../assets/images/sponsors/tripshot/Tripshot_Logo_RGB.png"></a>
    
  </div>
</div>

<div class="mt-20 bg-gray-800 w-full py-20">
  <div class="max-w-screen-xl mx-auto text-gray-300 text-lg px-6 lg:px-16">

    <div class="flex flex-col space-y-8 text-center lg:flex-row lg:space-y-0">
      <div class="lg:flex space-y-4 lg:gap-2 lg:flex-grow lg:space-y-0">
        <div class="font-medium mt-1">To learn more about the Haskell Foundation </div>
        <div class="ml-2">
          <a href="../../contact" class="arrow-link light">>> contact us</a>
        </div>
      </div>

      <div class="flex space-x-4 w-44">
        <a href="https://twitter.com/haskellfound" target="_blank" class="text-4xl block"><span class="fab fa-twitter"></span></a>
        <a href="https://www.linkedin.com/company/haskell-foundation-inc" target="_blank" class="text-4xl block"><span class="fab fa-linkedin-in"></span></a>
        <a href="https://discourse.haskell.org/c/haskell-foundation/11" target="_blank" class="text-4xl block"><span class="fab fa-discourse"></span></a>
        <a rel="me" href="https://mastodon.social/@haskell_foundation" target="_blank" class="text-4xl block"><span class="fab fa-mastodon"></span></a>
        <a href="https://www.youtube.com/@HaskellFoundation" target="_blank" class="text-4xl block"><span class="fab fa-youtube"></span></a>
        <a href="https://github.com/haskellfoundation" target="_blank" class="text-4xl block"><span class="fab fa-github"></span></a>
      </div>
    </div>

    <div class="flex flex-row">
      <div class="mt-16 flex flex-col text-center flex-grow lg:flex-row lg:space-x-8 lg:space-y-0">
        <img src="../../assets/images/logos/hf-logo-100-alpha.png" class="h-8" alt="Logo of the Haskell Foundation" />
        <div class="font-medium">2024 Â© Haskell Foundation, <a href="https://github.com/haskellfoundation/haskellfoundation.github.io">submit website bug reports and fixes on GitHub</a></div>
      </div>

      <div class="text-sm mt-6 flex ml-8 flex-col justify-items-start text-left">
        <div>Haskell Foundation, Inc.</div>
        <div>2093 Philadelphia Pike #8119</div>
        <div>Claymont, DE 19703</div>
        <div>USA</div>
      </div>
    </div>

  </div>
</div>

  </div>

</body>

</html>
